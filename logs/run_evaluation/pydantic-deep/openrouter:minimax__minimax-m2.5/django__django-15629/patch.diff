diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py
index 696bfd7742..0f503c353d 100644
--- a/django/db/backends/base/schema.py
+++ b/django/db/backends/base/schema.py
@@ -824,6 +824,16 @@ class BaseDatabaseSchemaEditor:
         # Drop incoming FK constraints if the field is a primary key or unique,
         # which might be a to_field target, and things are going to change.
         drop_foreign_keys = (
+            self.connection.features.supports_foreign_keys
+            and (
+                (old_field.primary_key and new_field.primary_key)
+                or (old_field.unique and new_field.unique)
+            )
+            and (
+                old_type != new_type
+                or old_db_params.get("collation") != new_db_params.get("collation")
+            )
+        )
             self.connection.features.supports_foreign_keys
             and (
                 (old_field.primary_key and new_field.primary_key)
@@ -1035,6 +1045,38 @@ class BaseDatabaseSchemaEditor:
             # Update all referencing columns
             rels_to_update.extend(_related_non_m2m_objects(old_field, new_field))
         # Handle our type alters on the other end of rels from the PK stuff above
+        for old_rel, new_rel in rels_to_update:
+            rel_db_params = new_rel.field.db_parameters(connection=self.connection)
+            rel_type = rel_db_params["type"]
+            old_rel_db_params = old_rel.field.db_parameters(connection=self.connection)
+            old_rel_collation = old_rel_db_params.get("collation")
+            new_rel_collation = rel_db_params.get("collation")
+            if old_rel_collation != new_rel_collation:
+                fragment = self._alter_column_collation_sql(
+                    new_rel.related_model, new_rel.field, rel_type, new_rel_collation
+                )
+                self.execute(
+                    self.sql_alter_column
+                    % {
+                        "table": self.quote_name(new_rel.related_model._meta.db_table),
+                        "changes": fragment[0],
+                    },
+                    fragment[1],
+                )
+            else:
+                fragment, other_actions = self._alter_column_type_sql(
+                    new_rel.related_model, old_rel.field, new_rel.field, rel_type
+                )
+                self.execute(
+                    self.sql_alter_column
+                    % {
+                        "table": self.quote_name(new_rel.related_model._meta.db_table),
+                        "changes": fragment[0],
+                    },
+                    fragment[1],
+                )
+                for sql, params in other_actions:
+                    self.execute(sql, params)
         for old_rel, new_rel in rels_to_update:
             rel_db_params = new_rel.field.db_parameters(connection=self.connection)
             rel_type = rel_db_params["type"]