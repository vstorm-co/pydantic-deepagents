+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z '' ']'
+++ export CONDA_SHLVL=0
+++ CONDA_SHLVL=0
+++ '[' -n '' ']'
+++++ dirname /opt/miniconda3/bin/conda
++++ dirname /opt/miniconda3/bin
+++ PATH=/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export PATH
+++ '[' -z '' ']'
+++ PS1=
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1=
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=1
+++ CONDA_SHLVL=1
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\''
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/esmf-activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/esmpy-activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/gdal-activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/geotiff-activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/libarrow_activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/libxml2_activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/proj4-activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/udunits2-activate.sh"'
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\''
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/esmf-activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/esmpy-activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/gdal-activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/geotiff-activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/libarrow_activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/libxml2_activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/proj4-activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/udunits2-activate.sh"'
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=2
++ CONDA_SHLVL=2
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_1=/opt/miniconda3
++ CONDA_PREFIX_1=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ . /opt/miniconda3/envs/testbed/etc/conda/activate.d/esmf-activate.sh
+++ '[' -n '' ']'
+++ '[' -f /opt/miniconda3/envs/testbed/lib/esmf.mk ']'
+++ export ESMFMKFILE=/opt/miniconda3/envs/testbed/lib/esmf.mk
+++ ESMFMKFILE=/opt/miniconda3/envs/testbed/lib/esmf.mk
++ . /opt/miniconda3/envs/testbed/etc/conda/activate.d/esmpy-activate.sh
+++ '[' -n /opt/miniconda3/envs/testbed/lib/esmf.mk ']'
+++ export _CONDA_SET_ESMFMKFILE=/opt/miniconda3/envs/testbed/lib/esmf.mk
+++ _CONDA_SET_ESMFMKFILE=/opt/miniconda3/envs/testbed/lib/esmf.mk
+++ '[' -f /opt/miniconda3/envs/testbed/lib/esmf.mk ']'
+++ export ESMFMKFILE=/opt/miniconda3/envs/testbed/lib/esmf.mk
+++ ESMFMKFILE=/opt/miniconda3/envs/testbed/lib/esmf.mk
++ . /opt/miniconda3/envs/testbed/etc/conda/activate.d/gdal-activate.sh
+++ '[' -n '' ']'
+++ '[' -n '' ']'
+++ '[' -d /opt/miniconda3/envs/testbed/share/gdal ']'
+++ export GDAL_DATA=/opt/miniconda3/envs/testbed/share/gdal
+++ GDAL_DATA=/opt/miniconda3/envs/testbed/share/gdal
+++ export GDAL_DRIVER_PATH=/opt/miniconda3/envs/testbed/lib/gdalplugins
+++ GDAL_DRIVER_PATH=/opt/miniconda3/envs/testbed/lib/gdalplugins
+++ '[' '!' -d /opt/miniconda3/envs/testbed/lib/gdalplugins ']'
+++ export CPL_ZIP_ENCODING=UTF-8
+++ CPL_ZIP_ENCODING=UTF-8
++ . /opt/miniconda3/envs/testbed/etc/conda/activate.d/geotiff-activate.sh
+++ '[' -n '' ']'
+++ '[' -d /opt/miniconda3/envs/testbed/share/epsg_csv ']'
+++ '[' -d /opt/miniconda3/envs/testbed/Library/share/epsg_csv ']'
++ . /opt/miniconda3/envs/testbed/etc/conda/activate.d/libarrow_activate.sh
+++ _la_log 'Beginning libarrow activation.'
+++ '[' '' = 1 ']'
+++ _la_gdb_prefix=/opt/miniconda3/envs/testbed/share/gdb/auto-load
+++ '[' '!' -w /opt/miniconda3/envs/testbed/share/gdb/auto-load ']'
+++ _la_placeholder=replace_this_section_with_absolute_slashed_path_to_CONDA_PREFIX
+++ _la_symlink_dir=/opt/miniconda3/envs/testbed/share/gdb/auto-load//opt/miniconda3/envs/testbed/lib
+++ _la_orig_install_dir=/opt/miniconda3/envs/testbed/share/gdb/auto-load/replace_this_section_with_absolute_slashed_path_to_CONDA_PREFIX/lib
+++ _la_log '          _la_gdb_prefix: /opt/miniconda3/envs/testbed/share/gdb/auto-load'
+++ '[' '' = 1 ']'
+++ _la_log '         _la_placeholder: replace_this_section_with_absolute_slashed_path_to_CONDA_PREFIX'
+++ '[' '' = 1 ']'
+++ _la_log '         _la_symlink_dir: /opt/miniconda3/envs/testbed/share/gdb/auto-load//opt/miniconda3/envs/testbed/lib'
+++ '[' '' = 1 ']'
+++ _la_log '    _la_orig_install_dir: /opt/miniconda3/envs/testbed/share/gdb/auto-load/replace_this_section_with_absolute_slashed_path_to_CONDA_PREFIX/lib'
+++ '[' '' = 1 ']'
+++ _la_log '  content of that folder:'
+++ '[' '' = 1 ']'
++++ ls -al /opt/miniconda3/envs/testbed/share/gdb/auto-load/replace_this_section_with_absolute_slashed_path_to_CONDA_PREFIX/lib
++++ sed 's/^/      /'
+++ _la_log '      total 12
      drwxr-xr-x 2 root root 4096 Sep 10 08:58 .
      drwxr-xr-x 3 root root 4096 Sep 10 08:58 ..
      -rw-r--r-- 1 root root  971 Sep 10 08:58 libarrow.so.1700.0.0-gdb.py'
+++ '[' '' = 1 ']'
+++ for _la_target in "$_la_orig_install_dir/"*.py
+++ '[' '!' -e /opt/miniconda3/envs/testbed/share/gdb/auto-load/replace_this_section_with_absolute_slashed_path_to_CONDA_PREFIX/lib/libarrow.so.1700.0.0-gdb.py ']'
++++ basename /opt/miniconda3/envs/testbed/share/gdb/auto-load/replace_this_section_with_absolute_slashed_path_to_CONDA_PREFIX/lib/libarrow.so.1700.0.0-gdb.py
+++ _la_symlink=/opt/miniconda3/envs/testbed/share/gdb/auto-load//opt/miniconda3/envs/testbed/lib/libarrow.so.1700.0.0-gdb.py
+++ _la_log '   _la_target: /opt/miniconda3/envs/testbed/share/gdb/auto-load/replace_this_section_with_absolute_slashed_path_to_CONDA_PREFIX/lib/libarrow.so.1700.0.0-gdb.py'
+++ '[' '' = 1 ']'
+++ _la_log '  _la_symlink: /opt/miniconda3/envs/testbed/share/gdb/auto-load//opt/miniconda3/envs/testbed/lib/libarrow.so.1700.0.0-gdb.py'
+++ '[' '' = 1 ']'
+++ '[' -L /opt/miniconda3/envs/testbed/share/gdb/auto-load//opt/miniconda3/envs/testbed/lib/libarrow.so.1700.0.0-gdb.py ']'
++++ readlink /opt/miniconda3/envs/testbed/share/gdb/auto-load//opt/miniconda3/envs/testbed/lib/libarrow.so.1700.0.0-gdb.py
+++ '[' /opt/miniconda3/envs/testbed/share/gdb/auto-load/replace_this_section_with_absolute_slashed_path_to_CONDA_PREFIX/lib/libarrow.so.1700.0.0-gdb.py = /opt/miniconda3/envs/testbed/share/gdb/auto-load/replace_this_section_with_absolute_slashed_path_to_CONDA_PREFIX/lib/libarrow.so.1700.0.0-gdb.py ']'
+++ _la_log 'symlink $_la_symlink already exists and points to $_la_target, skipping.'
+++ '[' '' = 1 ']'
+++ continue
+++ _la_log 'Libarrow activation complete.'
+++ '[' '' = 1 ']'
+++ unset _la_gdb_prefix
+++ unset _la_log
+++ unset _la_orig_install_dir
+++ unset _la_placeholder
+++ unset _la_symlink
+++ unset _la_symlink_dir
+++ unset _la_target
++ . /opt/miniconda3/envs/testbed/etc/conda/activate.d/libxml2_activate.sh
+++ test -n ''
+++ xml_catalog_files_libxml2=
+++ XML_CATALOG_FILES=
+++ conda_catalog_files=
+++ ifs_libxml2=' 	
'
+++ IFS=' '
+++ rem=/opt/miniconda3/envs/testbed
+++ for pre in ${rem}
+++ test '' = /opt/miniconda3/envs/testbed
+++ conda_catalog_files=/opt/miniconda3/envs/testbed
+++ rem=
+++ IFS=' 	
'
+++ conda_catalog_files='file:///opt/miniconda3/envs/testbed/etc/xml/catalog file:///etc/xml/catalog'
+++ export 'XML_CATALOG_FILES=file:///opt/miniconda3/envs/testbed/etc/xml/catalog file:///etc/xml/catalog'
+++ XML_CATALOG_FILES='file:///opt/miniconda3/envs/testbed/etc/xml/catalog file:///etc/xml/catalog'
+++ unset conda_catalog_files ifs_libxml2 rem
++ . /opt/miniconda3/envs/testbed/etc/conda/activate.d/proj4-activate.sh
+++ '[' -n '' ']'
+++ '[' -d /opt/miniconda3/envs/testbed/share/proj ']'
+++ export PROJ_DATA=/opt/miniconda3/envs/testbed/share/proj
+++ PROJ_DATA=/opt/miniconda3/envs/testbed/share/proj
+++ '[' -f /opt/miniconda3/envs/testbed/share/proj/copyright_and_licenses.csv ']'
+++ export PROJ_NETWORK=ON
+++ PROJ_NETWORK=ON
++ . /opt/miniconda3/envs/testbed/etc/conda/activate.d/udunits2-activate.sh
+++ '[' -n '' ']'
+++ '[' -d /opt/miniconda3/envs/testbed/share/udunits ']'
+++ export UDUNITS2_XML_PATH=/opt/miniconda3/envs/testbed/share/udunits/udunits2.xml
+++ UDUNITS2_XML_PATH=/opt/miniconda3/envs/testbed/share/udunits/udunits2.xml
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ cd /testbed
+ git config --global --add safe.directory /testbed
+ cd /testbed
+ git status
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   xarray/core/weighted.py

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	xarray/core/weighted.py.orig

no changes added to commit (use "git add" and/or "git commit -a")
+ git show
commit 84d2435f98e5f44454350fe9c26d1951d1c110b9
Author: SWE-bench <setup@swebench.config>
Date:   Wed Sep 10 15:02:51 2025 +0000

    SWE-bench
+ git -c core.fileMode=false diff 19b088636eb7d3f65ab7a1046ac672e0689371d8
diff --git a/xarray/core/weighted.py b/xarray/core/weighted.py
index 996d2e4c..9728fe6c 100644
--- a/xarray/core/weighted.py
+++ b/xarray/core/weighted.py
@@ -107,9 +107,9 @@ class Weighted:
             )
 
         self.obj = obj
-        self.weights = weights
-
-    @staticmethod
+        # Convert weights to float to avoid issues with boolean weights
+        # (e.g., boolean * boolean = boolean, but we need numeric types for dot product)
+        self.weights = weights.astype(float)
     def _reduce(
         da: "DataArray",
         weights: "DataArray",
+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z x ']'
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1='(testbed) '
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='. "/opt/miniconda3/envs/testbed/etc/conda/deactivate.d/udunits2-deactivate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/deactivate.d/proj4-deactivate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/deactivate.d/libxml2_deactivate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/deactivate.d/geotiff-deactivate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/deactivate.d/gdal-deactivate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/deactivate.d/esmpy-deactivate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/deactivate.d/esmf-deactivate.sh"
PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval '. "/opt/miniconda3/envs/testbed/etc/conda/deactivate.d/udunits2-deactivate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/deactivate.d/proj4-deactivate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/deactivate.d/libxml2_deactivate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/deactivate.d/geotiff-deactivate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/deactivate.d/gdal-deactivate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/deactivate.d/esmpy-deactivate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/deactivate.d/esmf-deactivate.sh"
PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ . /opt/miniconda3/envs/testbed/etc/conda/deactivate.d/udunits2-deactivate.sh
++++ unset UDUNITS2_XML_PATH
++++ '[' -n '' ']'
+++ . /opt/miniconda3/envs/testbed/etc/conda/deactivate.d/proj4-deactivate.sh
++++ unset PROJ_DATA
++++ unset PROJ_NETWORK
++++ '[' -n '' ']'
+++ . /opt/miniconda3/envs/testbed/etc/conda/deactivate.d/libxml2_deactivate.sh
++++ test -n ''
++++ unset XML_CATALOG_FILES
++++ unset xml_catalog_files_libxml2
+++ . /opt/miniconda3/envs/testbed/etc/conda/deactivate.d/geotiff-deactivate.sh
++++ unset GEOTIFF_CSV
++++ '[' -n '' ']'
+++ . /opt/miniconda3/envs/testbed/etc/conda/deactivate.d/gdal-deactivate.sh
++++ unset GDAL_DATA
++++ '[' -n '' ']'
++++ unset GDAL_DRIVER_PATH
++++ '[' -n '' ']'
++++ unset CPL_ZIP_ENCODING
+++ . /opt/miniconda3/envs/testbed/etc/conda/deactivate.d/esmpy-deactivate.sh
++++ unset ESMFMKFILE
++++ '[' -n /opt/miniconda3/envs/testbed/lib/esmf.mk ']'
++++ export ESMFMKFILE=/opt/miniconda3/envs/testbed/lib/esmf.mk
++++ ESMFMKFILE=/opt/miniconda3/envs/testbed/lib/esmf.mk
++++ unset _CONDA_SET_ESMFMKFILE
+++ . /opt/miniconda3/envs/testbed/etc/conda/deactivate.d/esmf-deactivate.sh
++++ unset ESMFMKFILE
++++ '[' -n '' ']'
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=3
+++ CONDA_SHLVL=3
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\''
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/esmf-activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/esmpy-activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/gdal-activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/geotiff-activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/libarrow_activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/libxml2_activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/proj4-activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/udunits2-activate.sh"'
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\''
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/esmf-activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/esmpy-activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/gdal-activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/geotiff-activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/libarrow_activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/libxml2_activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/proj4-activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/udunits2-activate.sh"'
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=4
++ CONDA_SHLVL=4
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_3=/opt/miniconda3
++ CONDA_PREFIX_3=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ . /opt/miniconda3/envs/testbed/etc/conda/activate.d/esmf-activate.sh
+++ '[' -n '' ']'
+++ '[' -f /opt/miniconda3/envs/testbed/lib/esmf.mk ']'
+++ export ESMFMKFILE=/opt/miniconda3/envs/testbed/lib/esmf.mk
+++ ESMFMKFILE=/opt/miniconda3/envs/testbed/lib/esmf.mk
++ . /opt/miniconda3/envs/testbed/etc/conda/activate.d/esmpy-activate.sh
+++ '[' -n /opt/miniconda3/envs/testbed/lib/esmf.mk ']'
+++ export _CONDA_SET_ESMFMKFILE=/opt/miniconda3/envs/testbed/lib/esmf.mk
+++ _CONDA_SET_ESMFMKFILE=/opt/miniconda3/envs/testbed/lib/esmf.mk
+++ '[' -f /opt/miniconda3/envs/testbed/lib/esmf.mk ']'
+++ export ESMFMKFILE=/opt/miniconda3/envs/testbed/lib/esmf.mk
+++ ESMFMKFILE=/opt/miniconda3/envs/testbed/lib/esmf.mk
++ . /opt/miniconda3/envs/testbed/etc/conda/activate.d/gdal-activate.sh
+++ '[' -n '' ']'
+++ '[' -n '' ']'
+++ '[' -d /opt/miniconda3/envs/testbed/share/gdal ']'
+++ export GDAL_DATA=/opt/miniconda3/envs/testbed/share/gdal
+++ GDAL_DATA=/opt/miniconda3/envs/testbed/share/gdal
+++ export GDAL_DRIVER_PATH=/opt/miniconda3/envs/testbed/lib/gdalplugins
+++ GDAL_DRIVER_PATH=/opt/miniconda3/envs/testbed/lib/gdalplugins
+++ '[' '!' -d /opt/miniconda3/envs/testbed/lib/gdalplugins ']'
+++ export CPL_ZIP_ENCODING=UTF-8
+++ CPL_ZIP_ENCODING=UTF-8
++ . /opt/miniconda3/envs/testbed/etc/conda/activate.d/geotiff-activate.sh
+++ '[' -n '' ']'
+++ '[' -d /opt/miniconda3/envs/testbed/share/epsg_csv ']'
+++ '[' -d /opt/miniconda3/envs/testbed/Library/share/epsg_csv ']'
++ . /opt/miniconda3/envs/testbed/etc/conda/activate.d/libarrow_activate.sh
+++ _la_log 'Beginning libarrow activation.'
+++ '[' '' = 1 ']'
+++ _la_gdb_prefix=/opt/miniconda3/envs/testbed/share/gdb/auto-load
+++ '[' '!' -w /opt/miniconda3/envs/testbed/share/gdb/auto-load ']'
+++ _la_placeholder=replace_this_section_with_absolute_slashed_path_to_CONDA_PREFIX
+++ _la_symlink_dir=/opt/miniconda3/envs/testbed/share/gdb/auto-load//opt/miniconda3/envs/testbed/lib
+++ _la_orig_install_dir=/opt/miniconda3/envs/testbed/share/gdb/auto-load/replace_this_section_with_absolute_slashed_path_to_CONDA_PREFIX/lib
+++ _la_log '          _la_gdb_prefix: /opt/miniconda3/envs/testbed/share/gdb/auto-load'
+++ '[' '' = 1 ']'
+++ _la_log '         _la_placeholder: replace_this_section_with_absolute_slashed_path_to_CONDA_PREFIX'
+++ '[' '' = 1 ']'
+++ _la_log '         _la_symlink_dir: /opt/miniconda3/envs/testbed/share/gdb/auto-load//opt/miniconda3/envs/testbed/lib'
+++ '[' '' = 1 ']'
+++ _la_log '    _la_orig_install_dir: /opt/miniconda3/envs/testbed/share/gdb/auto-load/replace_this_section_with_absolute_slashed_path_to_CONDA_PREFIX/lib'
+++ '[' '' = 1 ']'
+++ _la_log '  content of that folder:'
+++ '[' '' = 1 ']'
++++ ls -al /opt/miniconda3/envs/testbed/share/gdb/auto-load/replace_this_section_with_absolute_slashed_path_to_CONDA_PREFIX/lib
++++ sed 's/^/      /'
+++ _la_log '      total 12
      drwxr-xr-x 2 root root 4096 Sep 10 08:58 .
      drwxr-xr-x 3 root root 4096 Sep 10 08:58 ..
      -rw-r--r-- 1 root root  971 Sep 10 08:58 libarrow.so.1700.0.0-gdb.py'
+++ '[' '' = 1 ']'
+++ for _la_target in "$_la_orig_install_dir/"*.py
+++ '[' '!' -e /opt/miniconda3/envs/testbed/share/gdb/auto-load/replace_this_section_with_absolute_slashed_path_to_CONDA_PREFIX/lib/libarrow.so.1700.0.0-gdb.py ']'
++++ basename /opt/miniconda3/envs/testbed/share/gdb/auto-load/replace_this_section_with_absolute_slashed_path_to_CONDA_PREFIX/lib/libarrow.so.1700.0.0-gdb.py
+++ _la_symlink=/opt/miniconda3/envs/testbed/share/gdb/auto-load//opt/miniconda3/envs/testbed/lib/libarrow.so.1700.0.0-gdb.py
+++ _la_log '   _la_target: /opt/miniconda3/envs/testbed/share/gdb/auto-load/replace_this_section_with_absolute_slashed_path_to_CONDA_PREFIX/lib/libarrow.so.1700.0.0-gdb.py'
+++ '[' '' = 1 ']'
+++ _la_log '  _la_symlink: /opt/miniconda3/envs/testbed/share/gdb/auto-load//opt/miniconda3/envs/testbed/lib/libarrow.so.1700.0.0-gdb.py'
+++ '[' '' = 1 ']'
+++ '[' -L /opt/miniconda3/envs/testbed/share/gdb/auto-load//opt/miniconda3/envs/testbed/lib/libarrow.so.1700.0.0-gdb.py ']'
++++ readlink /opt/miniconda3/envs/testbed/share/gdb/auto-load//opt/miniconda3/envs/testbed/lib/libarrow.so.1700.0.0-gdb.py
+++ '[' /opt/miniconda3/envs/testbed/share/gdb/auto-load/replace_this_section_with_absolute_slashed_path_to_CONDA_PREFIX/lib/libarrow.so.1700.0.0-gdb.py = /opt/miniconda3/envs/testbed/share/gdb/auto-load/replace_this_section_with_absolute_slashed_path_to_CONDA_PREFIX/lib/libarrow.so.1700.0.0-gdb.py ']'
+++ _la_log 'symlink $_la_symlink already exists and points to $_la_target, skipping.'
+++ '[' '' = 1 ']'
+++ continue
+++ _la_log 'Libarrow activation complete.'
+++ '[' '' = 1 ']'
+++ unset _la_gdb_prefix
+++ unset _la_log
+++ unset _la_orig_install_dir
+++ unset _la_placeholder
+++ unset _la_symlink
+++ unset _la_symlink_dir
+++ unset _la_target
++ . /opt/miniconda3/envs/testbed/etc/conda/activate.d/libxml2_activate.sh
+++ test -n ''
+++ xml_catalog_files_libxml2=
+++ XML_CATALOG_FILES=
+++ conda_catalog_files=
+++ ifs_libxml2=' 	
'
+++ IFS=' '
+++ rem=/opt/miniconda3/envs/testbed
+++ for pre in ${rem}
+++ test '' = /opt/miniconda3/envs/testbed
+++ conda_catalog_files=/opt/miniconda3/envs/testbed
+++ rem=
+++ IFS=' 	
'
+++ conda_catalog_files='file:///opt/miniconda3/envs/testbed/etc/xml/catalog file:///etc/xml/catalog'
+++ export 'XML_CATALOG_FILES=file:///opt/miniconda3/envs/testbed/etc/xml/catalog file:///etc/xml/catalog'
+++ XML_CATALOG_FILES='file:///opt/miniconda3/envs/testbed/etc/xml/catalog file:///etc/xml/catalog'
+++ unset conda_catalog_files ifs_libxml2 rem
++ . /opt/miniconda3/envs/testbed/etc/conda/activate.d/proj4-activate.sh
+++ '[' -n '' ']'
+++ '[' -d /opt/miniconda3/envs/testbed/share/proj ']'
+++ export PROJ_DATA=/opt/miniconda3/envs/testbed/share/proj
+++ PROJ_DATA=/opt/miniconda3/envs/testbed/share/proj
+++ '[' -f /opt/miniconda3/envs/testbed/share/proj/copyright_and_licenses.csv ']'
+++ export PROJ_NETWORK=ON
+++ PROJ_NETWORK=ON
++ . /opt/miniconda3/envs/testbed/etc/conda/activate.d/udunits2-activate.sh
+++ '[' -n '' ']'
+++ '[' -d /opt/miniconda3/envs/testbed/share/udunits ']'
+++ export UDUNITS2_XML_PATH=/opt/miniconda3/envs/testbed/share/udunits/udunits2.xml
+++ UDUNITS2_XML_PATH=/opt/miniconda3/envs/testbed/share/udunits/udunits2.xml
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ python -m pip install -e .
Obtaining file:///testbed
  Preparing metadata (setup.py): started
  Preparing metadata (setup.py): finished with status 'done'
Requirement already satisfied: numpy>=1.15 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from xarray==0.15.2.dev72+g84d2435f9.d20260222) (1.23.0)
Requirement already satisfied: pandas>=0.25 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from xarray==0.15.2.dev72+g84d2435f9.d20260222) (1.5.3)
Requirement already satisfied: setuptools>=41.2 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from xarray==0.15.2.dev72+g84d2435f9.d20260222) (68.0.0)
Requirement already satisfied: python-dateutil>=2.8.1 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from pandas>=0.25->xarray==0.15.2.dev72+g84d2435f9.d20260222) (2.8.2)
Requirement already satisfied: pytz>=2020.1 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from pandas>=0.25->xarray==0.15.2.dev72+g84d2435f9.d20260222) (2023.3)
Requirement already satisfied: six>=1.5 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from python-dateutil>=2.8.1->pandas>=0.25->xarray==0.15.2.dev72+g84d2435f9.d20260222) (1.16.0)
Installing collected packages: xarray
  Attempting uninstall: xarray
    Found existing installation: xarray 0.15.2.dev71+g19b088636
    Uninstalling xarray-0.15.2.dev71+g19b088636:
      Successfully uninstalled xarray-0.15.2.dev71+g19b088636
  DEPRECATION: Legacy editable install of xarray==0.15.2.dev72+g84d2435f9.d20260222 from file:///testbed (setup.py develop) is deprecated. pip 25.0 will enforce this behaviour change. A possible replacement is to add a pyproject.toml or enable --use-pep517, and use setuptools >= 64. If the resulting installation is not behaving as expected, try using --config-settings editable_mode=compat. Please consult the setuptools documentation for more information. Discussion can be found at https://github.com/pypa/pip/issues/11457
  Running setup.py develop for xarray
Successfully installed xarray
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager, possibly rendering your system unusable.It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv. Use the --root-user-action option if you know what you are doing and want to suppress this warning.
+ git checkout 19b088636eb7d3f65ab7a1046ac672e0689371d8 xarray/tests/test_weighted.py
Updated 0 paths from 3bf98cbd
+ git apply -v -
Checking patch xarray/tests/test_weighted.py...
Applied patch xarray/tests/test_weighted.py cleanly.
+ : '>>>>> Start Test Output'
+ pytest -rA xarray/tests/test_weighted.py
============================= test session starts ==============================
platform linux -- Python 3.10.15, pytest-7.4.0, pluggy-1.5.0
rootdir: /testbed
configfile: setup.cfg
plugins: cov-5.0.0, hypothesis-6.114.0, xdist-3.6.1, env-1.1.5
collected 962 items

xarray/tests/test_weighted.py ......FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [  4%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 11%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 19%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 26%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 34%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 41%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 49%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 56%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 64%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 71%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 79%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 86%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 94%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFxx                 [100%]

=================================== FAILURES ===================================
_______________ test_weighted_sum_of_weights_no_nan[weights0-3] ________________

weights = <xarray.DataArray (dim_0: 2)>
array([1, 2])
Dimensions without coordinates: dim_0
expected = 3

    @pytest.mark.parametrize(
        ("weights", "expected"),
        (([1, 2], 3), ([2, 0], 2), ([0, 0], np.nan), ([-1, 1], np.nan)),
    )
    def test_weighted_sum_of_weights_no_nan(weights, expected):
    
        da = DataArray([1, 2])
        weights = DataArray(weights)
>       result = da.weighted(weights).sum_of_weights()

xarray/tests/test_weighted.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1, 2])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______________ test_weighted_sum_of_weights_no_nan[weights1-2] ________________

weights = <xarray.DataArray (dim_0: 2)>
array([2, 0])
Dimensions without coordinates: dim_0
expected = 2

    @pytest.mark.parametrize(
        ("weights", "expected"),
        (([1, 2], 3), ([2, 0], 2), ([0, 0], np.nan), ([-1, 1], np.nan)),
    )
    def test_weighted_sum_of_weights_no_nan(weights, expected):
    
        da = DataArray([1, 2])
        weights = DataArray(weights)
>       result = da.weighted(weights).sum_of_weights()

xarray/tests/test_weighted.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1, 2])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______________ test_weighted_sum_of_weights_no_nan[weights2-nan] _______________

weights = <xarray.DataArray (dim_0: 2)>
array([0, 0])
Dimensions without coordinates: dim_0
expected = nan

    @pytest.mark.parametrize(
        ("weights", "expected"),
        (([1, 2], 3), ([2, 0], 2), ([0, 0], np.nan), ([-1, 1], np.nan)),
    )
    def test_weighted_sum_of_weights_no_nan(weights, expected):
    
        da = DataArray([1, 2])
        weights = DataArray(weights)
>       result = da.weighted(weights).sum_of_weights()

xarray/tests/test_weighted.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1, 2])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______________ test_weighted_sum_of_weights_no_nan[weights3-nan] _______________

weights = <xarray.DataArray (dim_0: 2)>
array([-1,  1])
Dimensions without coordinates: dim_0
expected = nan

    @pytest.mark.parametrize(
        ("weights", "expected"),
        (([1, 2], 3), ([2, 0], 2), ([0, 0], np.nan), ([-1, 1], np.nan)),
    )
    def test_weighted_sum_of_weights_no_nan(weights, expected):
    
        da = DataArray([1, 2])
        weights = DataArray(weights)
>       result = da.weighted(weights).sum_of_weights()

xarray/tests/test_weighted.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1, 2])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_________________ test_weighted_sum_of_weights_nan[weights0-2] _________________

weights = <xarray.DataArray (dim_0: 2)>
array([1, 2])
Dimensions without coordinates: dim_0
expected = 2

    @pytest.mark.parametrize(
        ("weights", "expected"),
        (([1, 2], 2), ([2, 0], np.nan), ([0, 0], np.nan), ([-1, 1], 1)),
    )
    def test_weighted_sum_of_weights_nan(weights, expected):
    
        da = DataArray([np.nan, 2])
        weights = DataArray(weights)
>       result = da.weighted(weights).sum_of_weights()

xarray/tests/test_weighted.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan,  2.])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
________________ test_weighted_sum_of_weights_nan[weights1-nan] ________________

weights = <xarray.DataArray (dim_0: 2)>
array([2, 0])
Dimensions without coordinates: dim_0
expected = nan

    @pytest.mark.parametrize(
        ("weights", "expected"),
        (([1, 2], 2), ([2, 0], np.nan), ([0, 0], np.nan), ([-1, 1], 1)),
    )
    def test_weighted_sum_of_weights_nan(weights, expected):
    
        da = DataArray([np.nan, 2])
        weights = DataArray(weights)
>       result = da.weighted(weights).sum_of_weights()

xarray/tests/test_weighted.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan,  2.])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
________________ test_weighted_sum_of_weights_nan[weights2-nan] ________________

weights = <xarray.DataArray (dim_0: 2)>
array([0, 0])
Dimensions without coordinates: dim_0
expected = nan

    @pytest.mark.parametrize(
        ("weights", "expected"),
        (([1, 2], 2), ([2, 0], np.nan), ([0, 0], np.nan), ([-1, 1], 1)),
    )
    def test_weighted_sum_of_weights_nan(weights, expected):
    
        da = DataArray([np.nan, 2])
        weights = DataArray(weights)
>       result = da.weighted(weights).sum_of_weights()

xarray/tests/test_weighted.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan,  2.])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_________________ test_weighted_sum_of_weights_nan[weights3-1] _________________

weights = <xarray.DataArray (dim_0: 2)>
array([-1,  1])
Dimensions without coordinates: dim_0
expected = 1

    @pytest.mark.parametrize(
        ("weights", "expected"),
        (([1, 2], 2), ([2, 0], np.nan), ([0, 0], np.nan), ([-1, 1], 1)),
    )
    def test_weighted_sum_of_weights_nan(weights, expected):
    
        da = DataArray([np.nan, 2])
        weights = DataArray(weights)
>       result = da.weighted(weights).sum_of_weights()

xarray/tests/test_weighted.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan,  2.])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______________________ test_weighted_sum_of_weights_bool _______________________

    def test_weighted_sum_of_weights_bool():
        # https://github.com/pydata/xarray/issues/4074
    
        da = DataArray([1, 2])
        weights = DataArray([True, True])
>       result = da.weighted(weights).sum_of_weights()

xarray/tests/test_weighted.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1, 2])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_________________ test_weighted_sum_equal_weights[True-0-da0] __________________

da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
factor = 0, skipna = True

    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("factor", [0, 1, 3.14])
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_equal_weights(da, factor, skipna):
        # if all weights are 'f'; weighted sum is f times the ordinary sum
    
        da = DataArray(da)
        weights = xr.full_like(da, factor)
    
        expected = da.sum(skipna=skipna) * factor
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________________ test_weighted_sum_equal_weights[True-0-da1] __________________

da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
factor = 0, skipna = True

    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("factor", [0, 1, 3.14])
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_equal_weights(da, factor, skipna):
        # if all weights are 'f'; weighted sum is f times the ordinary sum
    
        da = DataArray(da)
        weights = xr.full_like(da, factor)
    
        expected = da.sum(skipna=skipna) * factor
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________________ test_weighted_sum_equal_weights[True-0-da2] __________________

da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
factor = 0, skipna = True

    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("factor", [0, 1, 3.14])
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_equal_weights(da, factor, skipna):
        # if all weights are 'f'; weighted sum is f times the ordinary sum
    
        da = DataArray(da)
        weights = xr.full_like(da, factor)
    
        expected = da.sum(skipna=skipna) * factor
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________________ test_weighted_sum_equal_weights[True-1-da0] __________________

da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
factor = 1, skipna = True

    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("factor", [0, 1, 3.14])
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_equal_weights(da, factor, skipna):
        # if all weights are 'f'; weighted sum is f times the ordinary sum
    
        da = DataArray(da)
        weights = xr.full_like(da, factor)
    
        expected = da.sum(skipna=skipna) * factor
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________________ test_weighted_sum_equal_weights[True-1-da1] __________________

da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
factor = 1, skipna = True

    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("factor", [0, 1, 3.14])
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_equal_weights(da, factor, skipna):
        # if all weights are 'f'; weighted sum is f times the ordinary sum
    
        da = DataArray(da)
        weights = xr.full_like(da, factor)
    
        expected = da.sum(skipna=skipna) * factor
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________________ test_weighted_sum_equal_weights[True-1-da2] __________________

da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
factor = 1, skipna = True

    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("factor", [0, 1, 3.14])
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_equal_weights(da, factor, skipna):
        # if all weights are 'f'; weighted sum is f times the ordinary sum
    
        da = DataArray(da)
        weights = xr.full_like(da, factor)
    
        expected = da.sum(skipna=skipna) * factor
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________________ test_weighted_sum_equal_weights[True-3.14-da0] ________________

da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
factor = 3.14, skipna = True

    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("factor", [0, 1, 3.14])
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_equal_weights(da, factor, skipna):
        # if all weights are 'f'; weighted sum is f times the ordinary sum
    
        da = DataArray(da)
        weights = xr.full_like(da, factor)
    
        expected = da.sum(skipna=skipna) * factor
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________________ test_weighted_sum_equal_weights[True-3.14-da1] ________________

da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
factor = 3.14, skipna = True

    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("factor", [0, 1, 3.14])
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_equal_weights(da, factor, skipna):
        # if all weights are 'f'; weighted sum is f times the ordinary sum
    
        da = DataArray(da)
        weights = xr.full_like(da, factor)
    
        expected = da.sum(skipna=skipna) * factor
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________________ test_weighted_sum_equal_weights[True-3.14-da2] ________________

da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
factor = 3.14, skipna = True

    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("factor", [0, 1, 3.14])
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_equal_weights(da, factor, skipna):
        # if all weights are 'f'; weighted sum is f times the ordinary sum
    
        da = DataArray(da)
        weights = xr.full_like(da, factor)
    
        expected = da.sum(skipna=skipna) * factor
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________________ test_weighted_sum_equal_weights[False-0-da0] _________________

da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
factor = 0, skipna = False

    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("factor", [0, 1, 3.14])
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_equal_weights(da, factor, skipna):
        # if all weights are 'f'; weighted sum is f times the ordinary sum
    
        da = DataArray(da)
        weights = xr.full_like(da, factor)
    
        expected = da.sum(skipna=skipna) * factor
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________________ test_weighted_sum_equal_weights[False-0-da1] _________________

da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
factor = 0, skipna = False

    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("factor", [0, 1, 3.14])
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_equal_weights(da, factor, skipna):
        # if all weights are 'f'; weighted sum is f times the ordinary sum
    
        da = DataArray(da)
        weights = xr.full_like(da, factor)
    
        expected = da.sum(skipna=skipna) * factor
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________________ test_weighted_sum_equal_weights[False-0-da2] _________________

da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
factor = 0, skipna = False

    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("factor", [0, 1, 3.14])
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_equal_weights(da, factor, skipna):
        # if all weights are 'f'; weighted sum is f times the ordinary sum
    
        da = DataArray(da)
        weights = xr.full_like(da, factor)
    
        expected = da.sum(skipna=skipna) * factor
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________________ test_weighted_sum_equal_weights[False-1-da0] _________________

da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
factor = 1, skipna = False

    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("factor", [0, 1, 3.14])
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_equal_weights(da, factor, skipna):
        # if all weights are 'f'; weighted sum is f times the ordinary sum
    
        da = DataArray(da)
        weights = xr.full_like(da, factor)
    
        expected = da.sum(skipna=skipna) * factor
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________________ test_weighted_sum_equal_weights[False-1-da1] _________________

da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
factor = 1, skipna = False

    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("factor", [0, 1, 3.14])
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_equal_weights(da, factor, skipna):
        # if all weights are 'f'; weighted sum is f times the ordinary sum
    
        da = DataArray(da)
        weights = xr.full_like(da, factor)
    
        expected = da.sum(skipna=skipna) * factor
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________________ test_weighted_sum_equal_weights[False-1-da2] _________________

da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
factor = 1, skipna = False

    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("factor", [0, 1, 3.14])
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_equal_weights(da, factor, skipna):
        # if all weights are 'f'; weighted sum is f times the ordinary sum
    
        da = DataArray(da)
        weights = xr.full_like(da, factor)
    
        expected = da.sum(skipna=skipna) * factor
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_______________ test_weighted_sum_equal_weights[False-3.14-da0] ________________

da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
factor = 3.14, skipna = False

    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("factor", [0, 1, 3.14])
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_equal_weights(da, factor, skipna):
        # if all weights are 'f'; weighted sum is f times the ordinary sum
    
        da = DataArray(da)
        weights = xr.full_like(da, factor)
    
        expected = da.sum(skipna=skipna) * factor
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_______________ test_weighted_sum_equal_weights[False-3.14-da1] ________________

da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
factor = 3.14, skipna = False

    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("factor", [0, 1, 3.14])
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_equal_weights(da, factor, skipna):
        # if all weights are 'f'; weighted sum is f times the ordinary sum
    
        da = DataArray(da)
        weights = xr.full_like(da, factor)
    
        expected = da.sum(skipna=skipna) * factor
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_______________ test_weighted_sum_equal_weights[False-3.14-da2] ________________

da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
factor = 3.14, skipna = False

    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("factor", [0, 1, 3.14])
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_equal_weights(da, factor, skipna):
        # if all weights are 'f'; weighted sum is f times the ordinary sum
    
        da = DataArray(da)
        weights = xr.full_like(da, factor)
    
        expected = da.sum(skipna=skipna) * factor
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________________ test_weighted_sum_no_nan[weights0-5] _____________________

weights = <xarray.DataArray (dim_0: 2)>
array([1, 2])
Dimensions without coordinates: dim_0
expected = 5

    @pytest.mark.parametrize(
        ("weights", "expected"), (([1, 2], 5), ([0, 2], 4), ([0, 0], 0))
    )
    def test_weighted_sum_no_nan(weights, expected):
    
        da = DataArray([1, 2])
    
        weights = DataArray(weights)
>       result = da.weighted(weights).sum()

xarray/tests/test_weighted.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1, 2])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________________ test_weighted_sum_no_nan[weights1-4] _____________________

weights = <xarray.DataArray (dim_0: 2)>
array([0, 2])
Dimensions without coordinates: dim_0
expected = 4

    @pytest.mark.parametrize(
        ("weights", "expected"), (([1, 2], 5), ([0, 2], 4), ([0, 0], 0))
    )
    def test_weighted_sum_no_nan(weights, expected):
    
        da = DataArray([1, 2])
    
        weights = DataArray(weights)
>       result = da.weighted(weights).sum()

xarray/tests/test_weighted.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1, 2])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________________ test_weighted_sum_no_nan[weights2-0] _____________________

weights = <xarray.DataArray (dim_0: 2)>
array([0, 0])
Dimensions without coordinates: dim_0
expected = 0

    @pytest.mark.parametrize(
        ("weights", "expected"), (([1, 2], 5), ([0, 2], 4), ([0, 0], 0))
    )
    def test_weighted_sum_no_nan(weights, expected):
    
        da = DataArray([1, 2])
    
        weights = DataArray(weights)
>       result = da.weighted(weights).sum()

xarray/tests/test_weighted.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1, 2])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________________ test_weighted_sum_nan[True-weights0-4] ____________________

weights = <xarray.DataArray (dim_0: 2)>
array([1, 2])
Dimensions without coordinates: dim_0
expected = 4, skipna = True

    @pytest.mark.parametrize(
        ("weights", "expected"), (([1, 2], 4), ([0, 2], 4), ([1, 0], 0), ([0, 0], 0))
    )
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_nan(weights, expected, skipna):
    
        da = DataArray([np.nan, 2])
    
        weights = DataArray(weights)
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan,  2.])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________________ test_weighted_sum_nan[True-weights1-4] ____________________

weights = <xarray.DataArray (dim_0: 2)>
array([0, 2])
Dimensions without coordinates: dim_0
expected = 4, skipna = True

    @pytest.mark.parametrize(
        ("weights", "expected"), (([1, 2], 4), ([0, 2], 4), ([1, 0], 0), ([0, 0], 0))
    )
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_nan(weights, expected, skipna):
    
        da = DataArray([np.nan, 2])
    
        weights = DataArray(weights)
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan,  2.])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________________ test_weighted_sum_nan[True-weights2-0] ____________________

weights = <xarray.DataArray (dim_0: 2)>
array([1, 0])
Dimensions without coordinates: dim_0
expected = 0, skipna = True

    @pytest.mark.parametrize(
        ("weights", "expected"), (([1, 2], 4), ([0, 2], 4), ([1, 0], 0), ([0, 0], 0))
    )
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_nan(weights, expected, skipna):
    
        da = DataArray([np.nan, 2])
    
        weights = DataArray(weights)
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan,  2.])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________________ test_weighted_sum_nan[True-weights3-0] ____________________

weights = <xarray.DataArray (dim_0: 2)>
array([0, 0])
Dimensions without coordinates: dim_0
expected = 0, skipna = True

    @pytest.mark.parametrize(
        ("weights", "expected"), (([1, 2], 4), ([0, 2], 4), ([1, 0], 0), ([0, 0], 0))
    )
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_nan(weights, expected, skipna):
    
        da = DataArray([np.nan, 2])
    
        weights = DataArray(weights)
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan,  2.])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________________ test_weighted_sum_nan[False-weights0-4] ____________________

weights = <xarray.DataArray (dim_0: 2)>
array([1, 2])
Dimensions without coordinates: dim_0
expected = 4, skipna = False

    @pytest.mark.parametrize(
        ("weights", "expected"), (([1, 2], 4), ([0, 2], 4), ([1, 0], 0), ([0, 0], 0))
    )
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_nan(weights, expected, skipna):
    
        da = DataArray([np.nan, 2])
    
        weights = DataArray(weights)
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan,  2.])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________________ test_weighted_sum_nan[False-weights1-4] ____________________

weights = <xarray.DataArray (dim_0: 2)>
array([0, 2])
Dimensions without coordinates: dim_0
expected = 4, skipna = False

    @pytest.mark.parametrize(
        ("weights", "expected"), (([1, 2], 4), ([0, 2], 4), ([1, 0], 0), ([0, 0], 0))
    )
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_nan(weights, expected, skipna):
    
        da = DataArray([np.nan, 2])
    
        weights = DataArray(weights)
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan,  2.])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________________ test_weighted_sum_nan[False-weights2-0] ____________________

weights = <xarray.DataArray (dim_0: 2)>
array([1, 0])
Dimensions without coordinates: dim_0
expected = 0, skipna = False

    @pytest.mark.parametrize(
        ("weights", "expected"), (([1, 2], 4), ([0, 2], 4), ([1, 0], 0), ([0, 0], 0))
    )
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_nan(weights, expected, skipna):
    
        da = DataArray([np.nan, 2])
    
        weights = DataArray(weights)
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan,  2.])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________________ test_weighted_sum_nan[False-weights3-0] ____________________

weights = <xarray.DataArray (dim_0: 2)>
array([0, 0])
Dimensions without coordinates: dim_0
expected = 0, skipna = False

    @pytest.mark.parametrize(
        ("weights", "expected"), (([1, 2], 4), ([0, 2], 4), ([1, 0], 0), ([0, 0], 0))
    )
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_sum_nan(weights, expected, skipna):
    
        da = DataArray([np.nan, 2])
    
        weights = DataArray(weights)
>       result = da.weighted(weights).sum(skipna=skipna)

xarray/tests/test_weighted.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan,  2.])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________________ test_weighted_mean_equal_weights[1-True-da0] _________________

da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
skipna = True, factor = 1

    @pytest.mark.filterwarnings("ignore:Mean of empty slice")
    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("skipna", (True, False))
    @pytest.mark.parametrize("factor", [1, 2, 3.14])
    def test_weighted_mean_equal_weights(da, skipna, factor):
        # if all weights are equal (!= 0), should yield the same result as mean
    
        da = DataArray(da)
    
        # all weights as 1.
        weights = xr.full_like(da, factor)
    
        expected = da.mean(skipna=skipna)
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________________ test_weighted_mean_equal_weights[1-True-da1] _________________

da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
skipna = True, factor = 1

    @pytest.mark.filterwarnings("ignore:Mean of empty slice")
    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("skipna", (True, False))
    @pytest.mark.parametrize("factor", [1, 2, 3.14])
    def test_weighted_mean_equal_weights(da, skipna, factor):
        # if all weights are equal (!= 0), should yield the same result as mean
    
        da = DataArray(da)
    
        # all weights as 1.
        weights = xr.full_like(da, factor)
    
        expected = da.mean(skipna=skipna)
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________________ test_weighted_mean_equal_weights[1-True-da2] _________________

da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
skipna = True, factor = 1

    @pytest.mark.filterwarnings("ignore:Mean of empty slice")
    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("skipna", (True, False))
    @pytest.mark.parametrize("factor", [1, 2, 3.14])
    def test_weighted_mean_equal_weights(da, skipna, factor):
        # if all weights are equal (!= 0), should yield the same result as mean
    
        da = DataArray(da)
    
        # all weights as 1.
        weights = xr.full_like(da, factor)
    
        expected = da.mean(skipna=skipna)
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________________ test_weighted_mean_equal_weights[1-False-da0] _________________

da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
skipna = False, factor = 1

    @pytest.mark.filterwarnings("ignore:Mean of empty slice")
    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("skipna", (True, False))
    @pytest.mark.parametrize("factor", [1, 2, 3.14])
    def test_weighted_mean_equal_weights(da, skipna, factor):
        # if all weights are equal (!= 0), should yield the same result as mean
    
        da = DataArray(da)
    
        # all weights as 1.
        weights = xr.full_like(da, factor)
    
        expected = da.mean(skipna=skipna)
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________________ test_weighted_mean_equal_weights[1-False-da1] _________________

da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
skipna = False, factor = 1

    @pytest.mark.filterwarnings("ignore:Mean of empty slice")
    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("skipna", (True, False))
    @pytest.mark.parametrize("factor", [1, 2, 3.14])
    def test_weighted_mean_equal_weights(da, skipna, factor):
        # if all weights are equal (!= 0), should yield the same result as mean
    
        da = DataArray(da)
    
        # all weights as 1.
        weights = xr.full_like(da, factor)
    
        expected = da.mean(skipna=skipna)
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________________ test_weighted_mean_equal_weights[1-False-da2] _________________

da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
skipna = False, factor = 1

    @pytest.mark.filterwarnings("ignore:Mean of empty slice")
    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("skipna", (True, False))
    @pytest.mark.parametrize("factor", [1, 2, 3.14])
    def test_weighted_mean_equal_weights(da, skipna, factor):
        # if all weights are equal (!= 0), should yield the same result as mean
    
        da = DataArray(da)
    
        # all weights as 1.
        weights = xr.full_like(da, factor)
    
        expected = da.mean(skipna=skipna)
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________________ test_weighted_mean_equal_weights[2-True-da0] _________________

da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
skipna = True, factor = 2

    @pytest.mark.filterwarnings("ignore:Mean of empty slice")
    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("skipna", (True, False))
    @pytest.mark.parametrize("factor", [1, 2, 3.14])
    def test_weighted_mean_equal_weights(da, skipna, factor):
        # if all weights are equal (!= 0), should yield the same result as mean
    
        da = DataArray(da)
    
        # all weights as 1.
        weights = xr.full_like(da, factor)
    
        expected = da.mean(skipna=skipna)
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________________ test_weighted_mean_equal_weights[2-True-da1] _________________

da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
skipna = True, factor = 2

    @pytest.mark.filterwarnings("ignore:Mean of empty slice")
    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("skipna", (True, False))
    @pytest.mark.parametrize("factor", [1, 2, 3.14])
    def test_weighted_mean_equal_weights(da, skipna, factor):
        # if all weights are equal (!= 0), should yield the same result as mean
    
        da = DataArray(da)
    
        # all weights as 1.
        weights = xr.full_like(da, factor)
    
        expected = da.mean(skipna=skipna)
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________________ test_weighted_mean_equal_weights[2-True-da2] _________________

da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
skipna = True, factor = 2

    @pytest.mark.filterwarnings("ignore:Mean of empty slice")
    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("skipna", (True, False))
    @pytest.mark.parametrize("factor", [1, 2, 3.14])
    def test_weighted_mean_equal_weights(da, skipna, factor):
        # if all weights are equal (!= 0), should yield the same result as mean
    
        da = DataArray(da)
    
        # all weights as 1.
        weights = xr.full_like(da, factor)
    
        expected = da.mean(skipna=skipna)
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________________ test_weighted_mean_equal_weights[2-False-da0] _________________

da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
skipna = False, factor = 2

    @pytest.mark.filterwarnings("ignore:Mean of empty slice")
    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("skipna", (True, False))
    @pytest.mark.parametrize("factor", [1, 2, 3.14])
    def test_weighted_mean_equal_weights(da, skipna, factor):
        # if all weights are equal (!= 0), should yield the same result as mean
    
        da = DataArray(da)
    
        # all weights as 1.
        weights = xr.full_like(da, factor)
    
        expected = da.mean(skipna=skipna)
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________________ test_weighted_mean_equal_weights[2-False-da1] _________________

da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
skipna = False, factor = 2

    @pytest.mark.filterwarnings("ignore:Mean of empty slice")
    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("skipna", (True, False))
    @pytest.mark.parametrize("factor", [1, 2, 3.14])
    def test_weighted_mean_equal_weights(da, skipna, factor):
        # if all weights are equal (!= 0), should yield the same result as mean
    
        da = DataArray(da)
    
        # all weights as 1.
        weights = xr.full_like(da, factor)
    
        expected = da.mean(skipna=skipna)
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________________ test_weighted_mean_equal_weights[2-False-da2] _________________

da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
skipna = False, factor = 2

    @pytest.mark.filterwarnings("ignore:Mean of empty slice")
    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("skipna", (True, False))
    @pytest.mark.parametrize("factor", [1, 2, 3.14])
    def test_weighted_mean_equal_weights(da, skipna, factor):
        # if all weights are equal (!= 0), should yield the same result as mean
    
        da = DataArray(da)
    
        # all weights as 1.
        weights = xr.full_like(da, factor)
    
        expected = da.mean(skipna=skipna)
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_______________ test_weighted_mean_equal_weights[3.14-True-da0] ________________

da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
skipna = True, factor = 3.14

    @pytest.mark.filterwarnings("ignore:Mean of empty slice")
    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("skipna", (True, False))
    @pytest.mark.parametrize("factor", [1, 2, 3.14])
    def test_weighted_mean_equal_weights(da, skipna, factor):
        # if all weights are equal (!= 0), should yield the same result as mean
    
        da = DataArray(da)
    
        # all weights as 1.
        weights = xr.full_like(da, factor)
    
        expected = da.mean(skipna=skipna)
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_______________ test_weighted_mean_equal_weights[3.14-True-da1] ________________

da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
skipna = True, factor = 3.14

    @pytest.mark.filterwarnings("ignore:Mean of empty slice")
    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("skipna", (True, False))
    @pytest.mark.parametrize("factor", [1, 2, 3.14])
    def test_weighted_mean_equal_weights(da, skipna, factor):
        # if all weights are equal (!= 0), should yield the same result as mean
    
        da = DataArray(da)
    
        # all weights as 1.
        weights = xr.full_like(da, factor)
    
        expected = da.mean(skipna=skipna)
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_______________ test_weighted_mean_equal_weights[3.14-True-da2] ________________

da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
skipna = True, factor = 3.14

    @pytest.mark.filterwarnings("ignore:Mean of empty slice")
    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("skipna", (True, False))
    @pytest.mark.parametrize("factor", [1, 2, 3.14])
    def test_weighted_mean_equal_weights(da, skipna, factor):
        # if all weights are equal (!= 0), should yield the same result as mean
    
        da = DataArray(da)
    
        # all weights as 1.
        weights = xr.full_like(da, factor)
    
        expected = da.mean(skipna=skipna)
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_______________ test_weighted_mean_equal_weights[3.14-False-da0] _______________

da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
skipna = False, factor = 3.14

    @pytest.mark.filterwarnings("ignore:Mean of empty slice")
    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("skipna", (True, False))
    @pytest.mark.parametrize("factor", [1, 2, 3.14])
    def test_weighted_mean_equal_weights(da, skipna, factor):
        # if all weights are equal (!= 0), should yield the same result as mean
    
        da = DataArray(da)
    
        # all weights as 1.
        weights = xr.full_like(da, factor)
    
        expected = da.mean(skipna=skipna)
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1., 2.])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_______________ test_weighted_mean_equal_weights[3.14-False-da1] _______________

da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
skipna = False, factor = 3.14

    @pytest.mark.filterwarnings("ignore:Mean of empty slice")
    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("skipna", (True, False))
    @pytest.mark.parametrize("factor", [1, 2, 3.14])
    def test_weighted_mean_equal_weights(da, skipna, factor):
        # if all weights are equal (!= 0), should yield the same result as mean
    
        da = DataArray(da)
    
        # all weights as 1.
        weights = xr.full_like(da, factor)
    
        expected = da.mean(skipna=skipna)
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([ 1., nan])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_______________ test_weighted_mean_equal_weights[3.14-False-da2] _______________

da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
skipna = False, factor = 3.14

    @pytest.mark.filterwarnings("ignore:Mean of empty slice")
    @pytest.mark.parametrize("da", ([1.0, 2], [1, np.nan], [np.nan, np.nan]))
    @pytest.mark.parametrize("skipna", (True, False))
    @pytest.mark.parametrize("factor", [1, 2, 3.14])
    def test_weighted_mean_equal_weights(da, skipna, factor):
        # if all weights are equal (!= 0), should yield the same result as mean
    
        da = DataArray(da)
    
        # all weights as 1.
        weights = xr.full_like(da, factor)
    
        expected = da.mean(skipna=skipna)
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan, nan])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________________ test_weighted_mean_no_nan[weights0-1.6] ____________________

weights = <xarray.DataArray (dim_0: 2)>
array([4, 6])
Dimensions without coordinates: dim_0
expected = <xarray.DataArray ()>
array(1.6)

    @pytest.mark.parametrize(
        ("weights", "expected"), (([4, 6], 1.6), ([1, 0], 1.0), ([0, 0], np.nan))
    )
    def test_weighted_mean_no_nan(weights, expected):
    
        da = DataArray([1, 2])
        weights = DataArray(weights)
        expected = DataArray(expected)
    
>       result = da.weighted(weights).mean()

xarray/tests/test_weighted.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1, 2])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________________ test_weighted_mean_no_nan[weights1-1.0] ____________________

weights = <xarray.DataArray (dim_0: 2)>
array([1, 0])
Dimensions without coordinates: dim_0
expected = <xarray.DataArray ()>
array(1.)

    @pytest.mark.parametrize(
        ("weights", "expected"), (([4, 6], 1.6), ([1, 0], 1.0), ([0, 0], np.nan))
    )
    def test_weighted_mean_no_nan(weights, expected):
    
        da = DataArray([1, 2])
        weights = DataArray(weights)
        expected = DataArray(expected)
    
>       result = da.weighted(weights).mean()

xarray/tests/test_weighted.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1, 2])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________________ test_weighted_mean_no_nan[weights2-nan] ____________________

weights = <xarray.DataArray (dim_0: 2)>
array([0, 0])
Dimensions without coordinates: dim_0
expected = <xarray.DataArray ()>
array(nan)

    @pytest.mark.parametrize(
        ("weights", "expected"), (([4, 6], 1.6), ([1, 0], 1.0), ([0, 0], np.nan))
    )
    def test_weighted_mean_no_nan(weights, expected):
    
        da = DataArray([1, 2])
        weights = DataArray(weights)
        expected = DataArray(expected)
    
>       result = da.weighted(weights).mean()

xarray/tests/test_weighted.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1, 2])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
__________________ test_weighted_mean_nan[True-weights0-2.0] ___________________

weights = <xarray.DataArray (dim_0: 2)>
array([4, 6])
Dimensions without coordinates: dim_0
expected = <xarray.DataArray ()>
array(2.), skipna = True

    @pytest.mark.parametrize(
        ("weights", "expected"), (([4, 6], 2.0), ([1, 0], np.nan), ([0, 0], np.nan))
    )
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_mean_nan(weights, expected, skipna):
    
        da = DataArray([np.nan, 2])
        weights = DataArray(weights)
    
        if skipna:
            expected = DataArray(expected)
        else:
            expected = DataArray(np.nan)
    
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan,  2.])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
__________________ test_weighted_mean_nan[True-weights1-nan] ___________________

weights = <xarray.DataArray (dim_0: 2)>
array([1, 0])
Dimensions without coordinates: dim_0
expected = <xarray.DataArray ()>
array(nan), skipna = True

    @pytest.mark.parametrize(
        ("weights", "expected"), (([4, 6], 2.0), ([1, 0], np.nan), ([0, 0], np.nan))
    )
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_mean_nan(weights, expected, skipna):
    
        da = DataArray([np.nan, 2])
        weights = DataArray(weights)
    
        if skipna:
            expected = DataArray(expected)
        else:
            expected = DataArray(np.nan)
    
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan,  2.])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
__________________ test_weighted_mean_nan[True-weights2-nan] ___________________

weights = <xarray.DataArray (dim_0: 2)>
array([0, 0])
Dimensions without coordinates: dim_0
expected = <xarray.DataArray ()>
array(nan), skipna = True

    @pytest.mark.parametrize(
        ("weights", "expected"), (([4, 6], 2.0), ([1, 0], np.nan), ([0, 0], np.nan))
    )
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_mean_nan(weights, expected, skipna):
    
        da = DataArray([np.nan, 2])
        weights = DataArray(weights)
    
        if skipna:
            expected = DataArray(expected)
        else:
            expected = DataArray(np.nan)
    
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan,  2.])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
__________________ test_weighted_mean_nan[False-weights0-2.0] __________________

weights = <xarray.DataArray (dim_0: 2)>
array([4, 6])
Dimensions without coordinates: dim_0
expected = <xarray.DataArray ()>
array(nan), skipna = False

    @pytest.mark.parametrize(
        ("weights", "expected"), (([4, 6], 2.0), ([1, 0], np.nan), ([0, 0], np.nan))
    )
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_mean_nan(weights, expected, skipna):
    
        da = DataArray([np.nan, 2])
        weights = DataArray(weights)
    
        if skipna:
            expected = DataArray(expected)
        else:
            expected = DataArray(np.nan)
    
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan,  2.])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
__________________ test_weighted_mean_nan[False-weights1-nan] __________________

weights = <xarray.DataArray (dim_0: 2)>
array([1, 0])
Dimensions without coordinates: dim_0
expected = <xarray.DataArray ()>
array(nan), skipna = False

    @pytest.mark.parametrize(
        ("weights", "expected"), (([4, 6], 2.0), ([1, 0], np.nan), ([0, 0], np.nan))
    )
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_mean_nan(weights, expected, skipna):
    
        da = DataArray([np.nan, 2])
        weights = DataArray(weights)
    
        if skipna:
            expected = DataArray(expected)
        else:
            expected = DataArray(np.nan)
    
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan,  2.])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
__________________ test_weighted_mean_nan[False-weights2-nan] __________________

weights = <xarray.DataArray (dim_0: 2)>
array([0, 0])
Dimensions without coordinates: dim_0
expected = <xarray.DataArray ()>
array(nan), skipna = False

    @pytest.mark.parametrize(
        ("weights", "expected"), (([4, 6], 2.0), ([1, 0], np.nan), ([0, 0], np.nan))
    )
    @pytest.mark.parametrize("skipna", (True, False))
    def test_weighted_mean_nan(weights, expected, skipna):
    
        da = DataArray([np.nan, 2])
        weights = DataArray(weights)
    
        if skipna:
            expected = DataArray(expected)
        else:
            expected = DataArray(np.nan)
    
>       result = da.weighted(weights).mean(skipna=skipna)

xarray/tests/test_weighted.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([nan,  2.])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________________________ test_weighted_mean_bool ____________________________

    def test_weighted_mean_bool():
        # https://github.com/pydata/xarray/issues/4074
        da = DataArray([1, 1])
        weights = DataArray([True, True])
        expected = DataArray(1)
    
>       result = da.weighted(weights).mean()

xarray/tests/test_weighted.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 2)>
array([1, 1])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________ test_weighted_operations_3D[True-None-True-sum_of_weights-a] _________

dim = 'a', operation = 'sum_of_weights', add_nans = True, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.95539142,         nan, -0.10656467,         nan],
        [  ....68750596]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_________ test_weighted_operations_3D[True-None-True-sum_of_weights-b] _________

dim = 'b', operation = 'sum_of_weights', add_nans = True, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 1.32414211, -0.23016986, -1.66139314,  0.74167189],
        [-0....20320231]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_________ test_weighted_operations_3D[True-None-True-sum_of_weights-c] _________

dim = 'c', operation = 'sum_of_weights', add_nans = True, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[        nan,  0.11139922,  0.52348797,  0.05117796],
        [ 0...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[True-None-True-sum_of_weights-dim3] ________

dim = ('a', 'b'), operation = 'sum_of_weights', add_nans = True, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[            nan,  2.93660556e-01,  1.19522218e-02,
             ...74874e-01]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[True-None-True-sum_of_weights-dim4] ________

dim = ('a', 'b', 'c'), operation = 'sum_of_weights', add_nans = True
skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.71766172, -1.92418365,         nan,  1.00365437],
        [ 0....13573787]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[True-None-True-sum_of_weights-None] ________

dim = None, operation = 'sum_of_weights', add_nans = True, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[        nan,  0.10220633,  1.43368907, -0.29508013],
        [-0....7891798 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______________ test_weighted_operations_3D[True-None-True-sum-a] _______________

dim = 'a', operation = 'sum', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-1.52354159,  1.61409276,  0.73249092, -1.8056796 ],
        [-1...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_3D[True-None-True-sum-b] _______________

dim = 'b', operation = 'sum', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-1.44768878,  0.73978871, -0.15805387, -0.03837674],
        [ 0....44058145]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_3D[True-None-True-sum-c] _______________

dim = 'c', operation = 'sum', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.35436462, -0.02946634,  0.46432137, -0.69732267],
        [ 0....16782209]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[True-None-True-sum-dim3] _____________

dim = ('a', 'b'), operation = 'sum', add_nans = True, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[        nan,  0.56844612,  0.78039023,  1.60778191],
        [-0....03779592]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[True-None-True-sum-dim4] _____________

dim = ('a', 'b', 'c'), operation = 'sum', add_nans = True, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[        nan, -1.20045865,         nan, -2.12621412],
        [  ....02717093]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[True-None-True-sum-None] _____________

dim = None, operation = 'sum', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.17386105,  0.09134993,  0.07665128,         nan],
        [ 0....0425137 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_3D[True-None-True-mean-a] ______________

dim = 'a', operation = 'mean', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.14933769,         nan,  0.09313714,  2.40566801],
        [  ....43577268]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_3D[True-None-True-mean-b] ______________

dim = 'b', operation = 'mean', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.35392759,         nan, -1.25119291,         nan],
        [  ....16865283]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_3D[True-None-True-mean-c] ______________

dim = 'c', operation = 'mean', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 1.5884163 ,  0.15494727, -1.91489846, -1.88808218],
        [-1....86406381]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-None-True-mean-dim3] _____________

dim = ('a', 'b'), operation = 'mean', add_nans = True, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-2.28714412,  1.15161763,         nan, -0.74955579],
        [-1....04300127]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-None-True-mean-dim4] _____________

dim = ('a', 'b', 'c'), operation = 'mean', add_nans = True, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.36584229,  0.95126611, -1.19498711,         nan],
        [-0....97178996]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-None-True-mean-None] _____________

dim = None, operation = 'mean', add_nans = True, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.93789949,         nan,  0.34916768,  0.08031199],
        [  ...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________ test_weighted_operations_3D[True-None-False-sum_of_weights-a] _________

dim = 'a', operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-1.70480482e+00, -1.20908704e+00, -1.37299141e+00,
          9.5...76449e-01]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
________ test_weighted_operations_3D[True-None-False-sum_of_weights-b] _________

dim = 'b', operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.5220787 ,  1.23609008,  0.62756835,  0.25658089],
        [-0....80660362]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
________ test_weighted_operations_3D[True-None-False-sum_of_weights-c] _________

dim = 'c', operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 9.19980096e-01,  5.81794324e-02,  1.94021531e-01,
          1.2...29020e+00]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[True-None-False-sum_of_weights-dim3] _______

dim = ('a', 'b'), operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.44735332,  0.63713613, -1.64071937,  1.29527477],
        [ 2....04009996]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[True-None-False-sum_of_weights-dim4] _______

dim = ('a', 'b', 'c'), operation = 'sum_of_weights', add_nans = False
skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-1.33290971,  0.564729  , -0.3880831 , -0.49105716],
        [ 0....41896551]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[True-None-False-sum_of_weights-None] _______

dim = None, operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 5.29401434e-01, -4.25323500e-01,  7.22086180e-01,
         -1.1...63941e-01]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______________ test_weighted_operations_3D[True-None-False-sum-a] ______________

dim = 'a', operation = 'sum', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.97303592, -1.4007236 ,  0.75824696, -0.61483986],
        [-0....59259639]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_3D[True-None-False-sum-b] ______________

dim = 'b', operation = 'sum', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-1.19734691,  1.02446663, -0.53906504, -1.14833245],
        [ 0....88703162]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_3D[True-None-False-sum-c] ______________

dim = 'c', operation = 'sum', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.86483609, -1.27198188,  1.80042282,  0.77283299],
        [ 1....14015063]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-None-False-sum-dim3] _____________

dim = ('a', 'b'), operation = 'sum', add_nans = False, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.42137576,  0.30081101, -0.60108764, -1.68161673],
        [ 2....27327669]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-None-False-sum-dim4] _____________

dim = ('a', 'b', 'c'), operation = 'sum', add_nans = False, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.47162019, -0.30258531,  1.19439716,  1.09492468],
        [-0....03047772]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-None-False-sum-None] _____________

dim = None, operation = 'sum', add_nans = False, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.21344877,  0.58126894,  2.01878755,  0.85448694],
        [-0....27753766]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[True-None-False-mean-a] ______________

dim = 'a', operation = 'mean', add_nans = False, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.13877998,  1.83553814, -0.25588231, -1.25457654],
        [ 0....30767789]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[True-None-False-mean-b] ______________

dim = 'b', operation = 'mean', add_nans = False, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.824818  , -2.8005067 ,  0.77394461,  0.69754205],
        [ 0....15267618]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[True-None-False-mean-c] ______________

dim = 'c', operation = 'mean', add_nans = False, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.76359667, -0.10168189,  0.68251604,  1.16225929],
        [ 0....06555681]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-None-False-mean-dim3] ____________

dim = ('a', 'b'), operation = 'mean', add_nans = False, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.34612211, -2.70248537,  0.86649456, -1.06143112],
        [ 0....20380215]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-None-False-mean-dim4] ____________

dim = ('a', 'b', 'c'), operation = 'mean', add_nans = False, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 2.57617354,  0.32870711, -0.38876983,  0.10543586],
        [-0....57692459]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-None-False-mean-None] ____________

dim = None, operation = 'mean', add_nans = False, skipna = None
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-1.22867168,  0.39278284,  0.75541537,  1.45672679],
        [-1....10438664]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________ test_weighted_operations_3D[True-True-True-sum_of_weights-a] _________

dim = 'a', operation = 'sum_of_weights', add_nans = True, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-1.21423361, -0.17064945,  1.57588659,         nan],
        [-1....44074379]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_________ test_weighted_operations_3D[True-True-True-sum_of_weights-b] _________

dim = 'b', operation = 'sum_of_weights', add_nans = True, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.37500697,  1.49804831,         nan,  0.22170282],
        [ 1...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_________ test_weighted_operations_3D[True-True-True-sum_of_weights-c] _________

dim = 'c', operation = 'sum_of_weights', add_nans = True, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.73479429,  0.69800279, -1.2176579 , -0.62120992],
        [-0....23696392]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[True-True-True-sum_of_weights-dim3] ________

dim = ('a', 'b'), operation = 'sum_of_weights', add_nans = True, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 8.18756146e-01, -3.77262560e-01, -3.24871971e-04,
          4.7...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[True-True-True-sum_of_weights-dim4] ________

dim = ('a', 'b', 'c'), operation = 'sum_of_weights', add_nans = True
skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.40726751,  0.86458231,  0.44451959, -0.47619165],
        [-0....83068476]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[True-True-True-sum_of_weights-None] ________

dim = None, operation = 'sum_of_weights', add_nans = True, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.51993518, -0.02647891,         nan, -1.48385995],
        [-1....18739925]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______________ test_weighted_operations_3D[True-True-True-sum-a] _______________

dim = 'a', operation = 'sum', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.11102471, -0.35636541,         nan,  1.08860056],
        [-0...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_3D[True-True-True-sum-b] _______________

dim = 'b', operation = 'sum', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.19680293,  0.81998165,  0.29304466,         nan],
        [-1...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_3D[True-True-True-sum-c] _______________

dim = 'c', operation = 'sum', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.96300185,  0.71702574,  0.11379753,  0.83678066],
        [  ...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[True-True-True-sum-dim3] _____________

dim = ('a', 'b'), operation = 'sum', add_nans = True, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.33251153,         nan,  0.17040452, -1.10358284],
        [-0....37355859]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[True-True-True-sum-dim4] _____________

dim = ('a', 'b', 'c'), operation = 'sum', add_nans = True, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.40899662, -0.72354547,         nan,  0.20000428],
        [-0....11199361]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[True-True-True-sum-None] _____________

dim = None, operation = 'sum', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.19873899,         nan, -0.97080702, -0.28922709],
        [-0....8346696 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_3D[True-True-True-mean-a] ______________

dim = 'a', operation = 'mean', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[        nan, -0.69130715, -1.24895874,  1.91922383],
        [-2....73224197]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_3D[True-True-True-mean-b] ______________

dim = 'b', operation = 'mean', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[        nan,  0.2817215 ,  0.05659656,  0.14905683],
        [  ....6224141 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_3D[True-True-True-mean-c] ______________

dim = 'c', operation = 'mean', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 1.14511114, -1.59145138, -0.3399137 ,  0.47090922],
        [ 1....82368668]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-True-True-mean-dim3] _____________

dim = ('a', 'b'), operation = 'mean', add_nans = True, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.99803088,         nan,  1.09639385,         nan],
        [ 0...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-True-True-mean-dim4] _____________

dim = ('a', 'b', 'c'), operation = 'mean', add_nans = True, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[        nan,  0.32923089,         nan,  3.05254587],
        [ 2....05999368]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-True-True-mean-None] _____________

dim = None, operation = 'mean', add_nans = True, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[        nan,  0.75226712, -0.20402249, -0.26544591],
        [-1....48221597]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________ test_weighted_operations_3D[True-True-False-sum_of_weights-a] _________

dim = 'a', operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 1.65363784,  0.44776032, -0.05144993,  0.63172029],
        [-0....59066869]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
________ test_weighted_operations_3D[True-True-False-sum_of_weights-b] _________

dim = 'b', operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.24131577, -1.52926012,  0.23639215, -0.08617076],
        [-0....60983324]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
________ test_weighted_operations_3D[True-True-False-sum_of_weights-c] _________

dim = 'c', operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.39962793,  1.66782022,  1.70572245,  2.09125693],
        [ 0....14681715]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[True-True-False-sum_of_weights-dim3] _______

dim = ('a', 'b'), operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 1.60892097, -0.71094445,  0.05848301, -2.18364081],
        [ 1....98419782]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[True-True-False-sum_of_weights-dim4] _______

dim = ('a', 'b', 'c'), operation = 'sum_of_weights', add_nans = False
skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.26835601, -0.10240616, -1.92719531,  1.08742075],
        [-0....1275895 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[True-True-False-sum_of_weights-None] _______

dim = None, operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-1.6045636 ,  0.71846227, -0.49091843,  0.47983891],
        [-0....76028831]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______________ test_weighted_operations_3D[True-True-False-sum-a] ______________

dim = 'a', operation = 'sum', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-1.95757248, -2.54631842, -0.4971538 , -0.3677999 ],
        [-0....5014525 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_3D[True-True-False-sum-b] ______________

dim = 'b', operation = 'sum', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.93141071, -1.09408252,  1.13231698,  1.05356892],
        [-0....50763167]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_3D[True-True-False-sum-c] ______________

dim = 'c', operation = 'sum', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-1.1352579 , -0.18993893, -0.47535476,  0.68963875],
        [-0....3943708 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-True-False-sum-dim3] _____________

dim = ('a', 'b'), operation = 'sum', add_nans = False, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-1.50555668, -0.77008188, -0.69430235,  0.09681193],
        [-0....53721342]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-True-False-sum-dim4] _____________

dim = ('a', 'b', 'c'), operation = 'sum', add_nans = False, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.48896848,  0.68356871,  0.17583901,  0.41624364],
        [-0....66529441]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-True-False-sum-None] _____________

dim = None, operation = 'sum', add_nans = False, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-1.38094932, -0.55338117, -2.16953099, -0.33717097],
        [ 0....7942368 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[True-True-False-mean-a] ______________

dim = 'a', operation = 'mean', add_nans = False, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.27545012, -1.06393943, -1.04232038,  0.54060994],
        [ 1....09490124]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[True-True-False-mean-b] ______________

dim = 'b', operation = 'mean', add_nans = False, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.55592901, -2.41949795, -0.25220063, -0.10658001],
        [-1....50450096]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[True-True-False-mean-c] ______________

dim = 'c', operation = 'mean', add_nans = False, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 1.60048673, -1.01539138, -0.81879524, -0.58076047],
        [-0....50697502]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-True-False-mean-dim3] ____________

dim = ('a', 'b'), operation = 'mean', add_nans = False, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.74702522, -0.19695326,  0.72614114, -1.4691633 ],
        [-1....21665976]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-True-False-mean-dim4] ____________

dim = ('a', 'b', 'c'), operation = 'mean', add_nans = False, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-1.0223828 , -0.1857313 ,  0.04575964,  0.56598   ],
        [-0....36734652]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-True-False-mean-None] ____________

dim = None, operation = 'mean', add_nans = False, skipna = True
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.37866284,  1.19212251, -0.5820963 , -0.55273311],
        [-1....33538078]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________ test_weighted_operations_3D[True-False-True-sum_of_weights-a] _________

dim = 'a', operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 1.99305129, -0.96683356,  0.17487881,         nan],
        [ 0....35197696]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
________ test_weighted_operations_3D[True-False-True-sum_of_weights-b] _________

dim = 'b', operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.36275425,  0.31537564,         nan, -0.79350096],
        [-0....75587787]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
________ test_weighted_operations_3D[True-False-True-sum_of_weights-c] _________

dim = 'c', operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 2.73248282, -0.86038059, -0.97729444, -0.13212662],
        [-0....1419181 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[True-False-True-sum_of_weights-dim3] _______

dim = ('a', 'b'), operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-2.29828134,  0.36442601, -1.58937869, -0.42547051],
        [ 0....52450715]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[True-False-True-sum_of_weights-dim4] _______

dim = ('a', 'b', 'c'), operation = 'sum_of_weights', add_nans = True
skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[            nan, -1.32606250e+00,  1.22677150e+00,
          1.9...50964e-01]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[True-False-True-sum_of_weights-None] _______

dim = None, operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.64111166, -0.27661285,  0.60786639,  1.04687366],
        [ 0....51586201]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______________ test_weighted_operations_3D[True-False-True-sum-a] ______________

dim = 'a', operation = 'sum', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.42833427,  1.62647298,  1.13939179, -0.90036066],
        [-3...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_3D[True-False-True-sum-b] ______________

dim = 'b', operation = 'sum', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.33757287, -0.84029667,  0.69314153,         nan],
        [  ...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_3D[True-False-True-sum-c] ______________

dim = 'c', operation = 'sum', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.43657301,         nan,  2.34207375, -0.11861847],
        [-0...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-False-True-sum-dim3] _____________

dim = ('a', 'b'), operation = 'sum', add_nans = True, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 1.09493387, -0.62144174,         nan, -0.20596605],
        [-0...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-False-True-sum-dim4] _____________

dim = ('a', 'b', 'c'), operation = 'sum', add_nans = True, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.7313718 ,         nan,         nan,         nan],
        [-0....48609138]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-False-True-sum-None] _____________

dim = None, operation = 'sum', add_nans = True, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 1.52823291,  0.49948513,  0.96902433,         nan],
        [  ....80117358]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[True-False-True-mean-a] ______________

dim = 'a', operation = 'mean', add_nans = True, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.8524962 , -1.39133782,  1.66760017,  0.07993286],
        [  ...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[True-False-True-mean-b] ______________

dim = 'b', operation = 'mean', add_nans = True, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 1.68424552, -0.18467165,  0.76447893,  0.60619744],
        [-1....07911569]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[True-False-True-mean-c] ______________

dim = 'c', operation = 'mean', add_nans = True, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 1.15641243,  1.29442045, -0.90955396,         nan],
        [-0....71723198]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-False-True-mean-dim3] ____________

dim = ('a', 'b'), operation = 'mean', add_nans = True, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-1.1808357 , -0.14582873,  0.74623827,  0.69977302],
        [ 1...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-False-True-mean-dim4] ____________

dim = ('a', 'b', 'c'), operation = 'mean', add_nans = True, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.00282865,         nan, -0.98953165,  1.77960288],
        [-1...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-False-True-mean-None] ____________

dim = None, operation = 'mean', add_nans = True, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[        nan,  1.07409913,         nan, -0.10967341],
        [  ....00976884]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________ test_weighted_operations_3D[True-False-False-sum_of_weights-a] ________

dim = 'a', operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 1.14735767,  1.29023179,  0.6321531 ,  1.16029597],
        [-0....57861986]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
________ test_weighted_operations_3D[True-False-False-sum_of_weights-b] ________

dim = 'b', operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.25897302, -0.11111934,  0.36450932,  0.62931538],
        [ 0....60002323]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
________ test_weighted_operations_3D[True-False-False-sum_of_weights-c] ________

dim = 'c', operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 1.96709223e-01, -5.81283376e-01,  1.32895528e+00,
          6.2...81796e-01]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______ test_weighted_operations_3D[True-False-False-sum_of_weights-dim3] _______

dim = ('a', 'b'), operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.10824635, -1.98517389,  0.9412425 ,  1.27545446],
        [-2....01006865]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______ test_weighted_operations_3D[True-False-False-sum_of_weights-dim4] _______

dim = ('a', 'b', 'c'), operation = 'sum_of_weights', add_nans = False
skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.94591011, -2.61610229,  0.36787166,  0.75911202],
        [ 0....2546911 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______ test_weighted_operations_3D[True-False-False-sum_of_weights-None] _______

dim = None, operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 1.12873681,  2.0739991 ,  0.25958727, -0.13516319],
        [-0....24099751]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_____________ test_weighted_operations_3D[True-False-False-sum-a] ______________

dim = 'a', operation = 'sum', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.61941328, -0.28167266, -0.92921904,  0.63051025],
        [ 0....68824203]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[True-False-False-sum-b] ______________

dim = 'b', operation = 'sum', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 1.34999515, -0.53663393, -0.54073722, -0.8872695 ],
        [-0....27105928]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[True-False-False-sum-c] ______________

dim = 'c', operation = 'sum', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.52064857, -1.4559519 ,  0.98408354, -1.44149105],
        [ 0....95309035]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-False-False-sum-dim3] ____________

dim = ('a', 'b'), operation = 'sum', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-1.63338372, -0.05283391,  0.50262911,  1.34328431],
        [-1....01637199]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-False-False-sum-dim4] ____________

dim = ('a', 'b', 'c'), operation = 'sum', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 1.49335086, -0.70032654,  1.41823889,  0.61515159],
        [ 0....20350558]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[True-False-False-sum-None] ____________

dim = None, operation = 'sum', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 2.58393075e-01, -2.36976973e-01,  2.05402870e-02,
          1.6...57041e-01]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[True-False-False-mean-a] _____________

dim = 'a', operation = 'mean', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-6.95337510e-01, -4.44789482e-01, -2.52961270e-01,
         -7.7...66694e-01]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[True-False-False-mean-b] _____________

dim = 'b', operation = 'mean', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-1.16847224,  0.90532493, -0.19456518, -0.59863808],
        [ 0....01836852]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[True-False-False-mean-c] _____________

dim = 'c', operation = 'mean', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.61377501, -0.49669745, -1.27108149, -0.118568  ],
        [ 1....6268563 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________ test_weighted_operations_3D[True-False-False-mean-dim3] ____________

dim = ('a', 'b'), operation = 'mean', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 3.1478185 , -0.01288089,  0.30948596, -0.15735763],
        [ 0....71026644]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________ test_weighted_operations_3D[True-False-False-mean-dim4] ____________

dim = ('a', 'b', 'c'), operation = 'mean', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[-0.01617233,  0.21445382,  1.66661223, -0.84681415],
        [ 0....05275232]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________ test_weighted_operations_3D[True-False-False-mean-None] ____________

dim = None, operation = 'mean', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray 'data' (a: 4, b: 4, c: 4)>
array([[[ 0.32318802,  0.84377313,  0.08969944,  0.75179432],
        [-0....38407087]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________ test_weighted_operations_3D[False-None-True-sum_of_weights-a] _________

dim = 'a', operation = 'sum_of_weights', add_nans = True, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-1.22771082,         nan,         nan, -1.46459716],
        [ 1.098898...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
________ test_weighted_operations_3D[False-None-True-sum_of_weights-b] _________

dim = 'b', operation = 'sum_of_weights', add_nans = True, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.82602615, -1.6258867 , -1.2427317 ,  0.14555792],
        [ 1.214940....88879548]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
________ test_weighted_operations_3D[False-None-True-sum_of_weights-c] _________

dim = 'c', operation = 'sum_of_weights', add_nans = True, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 1.07534357,         nan,         nan, -1.38762776],
        [ 0.112854....14413702]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[False-None-True-sum_of_weights-dim3] _______

dim = ('a', 'b'), operation = 'sum_of_weights', add_nans = True, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.46678813,         nan,  0.51499046,  0.37745065],
        [-0.158002...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[False-None-True-sum_of_weights-dim4] _______

dim = ('a', 'b', 'c'), operation = 'sum_of_weights', add_nans = True
skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.69954629,         nan,         nan,  0.54870343],
        [        n....0379981 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[False-None-True-sum_of_weights-None] _______

dim = None, operation = 'sum_of_weights', add_nans = True, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[        nan, -0.00900025,  1.69404053,  0.11902285],
        [        n....91905141]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______________ test_weighted_operations_3D[False-None-True-sum-a] ______________

dim = 'a', operation = 'sum', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[        nan,         nan,         nan,         nan],
        [ 1.380990....69140477]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_3D[False-None-True-sum-b] ______________

dim = 'b', operation = 'sum', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.36477976,         nan,  1.46072871, -2.31293412],
        [        n....10658385]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_3D[False-None-True-sum-c] ______________

dim = 'c', operation = 'sum', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.84660181,  2.68023374, -1.69621355, -1.51363823],
        [-0.642329....77988475]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-None-True-sum-dim3] _____________

dim = ('a', 'b'), operation = 'sum', add_nans = True, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.24677505,         nan, -0.3659893 ,  0.40530042],
        [-0.563215....04379037]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-None-True-sum-dim4] _____________

dim = ('a', 'b', 'c'), operation = 'sum', add_nans = True, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 2.55966694, -0.69492136, -0.12894943, -0.56927834],
        [        n...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-None-True-sum-None] _____________

dim = None, operation = 'sum', add_nans = True, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.55023707,  0.44682812, -0.26994374,  1.30091974],
        [ 0.742170...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-None-True-mean-a] ______________

dim = 'a', operation = 'mean', add_nans = True, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.39570436,         nan, -0.51310642,         nan],
        [ 0.035285...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-None-True-mean-b] ______________

dim = 'b', operation = 'mean', add_nans = True, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[        nan,  0.51094568,  2.00340132,         nan],
        [-0.925592....02107681]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-None-True-mean-c] ______________

dim = 'c', operation = 'mean', add_nans = True, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.22950974, -0.10995253,         nan, -0.81636672],
        [-0.813287....16385979]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-None-True-mean-dim3] ____________

dim = ('a', 'b'), operation = 'mean', add_nans = True, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[        nan,  0.25653146, -1.2940947 ,         nan],
        [ 0.942264....63211886]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-None-True-mean-dim4] ____________

dim = ('a', 'b', 'c'), operation = 'mean', add_nans = True, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.0229186 , -0.96524621,         nan,  0.1405055 ],
        [-1.413207....38717807]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-None-True-mean-None] ____________

dim = None, operation = 'mean', add_nans = True, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.25189743,  1.50343359,         nan,  0.18210841],
        [ 2.341976....56648474]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________ test_weighted_operations_3D[False-None-False-sum_of_weights-a] ________

dim = 'a', operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 1.03899913,  1.5253199 , -0.39996936, -0.716099  ],
        [-0.268813....13370241]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
________ test_weighted_operations_3D[False-None-False-sum_of_weights-b] ________

dim = 'b', operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.0664066 , -0.96340957, -0.21128807,  2.32673561],
        [ 0.726976....00530849]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
________ test_weighted_operations_3D[False-None-False-sum_of_weights-c] ________

dim = 'c', operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-1.5155946 ,  1.41997667,  1.21025417,  2.34302681],
        [-0.846941....29050957]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______ test_weighted_operations_3D[False-None-False-sum_of_weights-dim3] _______

dim = ('a', 'b'), operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.08171552,  0.25381787,  0.43561821,  0.92921211],
        [ 1.397549....33821293]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______ test_weighted_operations_3D[False-None-False-sum_of_weights-dim4] _______

dim = ('a', 'b', 'c'), operation = 'sum_of_weights', add_nans = False
skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-1.36204999e+00, -2.04087299e+00,  1.68349998e+00,
         -1.17782590...49480e-01]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______ test_weighted_operations_3D[False-None-False-sum_of_weights-None] _______

dim = None, operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-1.29934548,  1.55160911, -0.0349658 , -2.62267807],
        [-0.818934....61691496]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_____________ test_weighted_operations_3D[False-None-False-sum-a] ______________

dim = 'a', operation = 'sum', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-1.23610482,  0.61638276, -0.88931836,  1.40242789],
        [ 0.875933....74714434]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-None-False-sum-b] ______________

dim = 'b', operation = 'sum', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.04824004, -0.08924567, -0.6259426 ,  0.54702019],
        [-1.070963....24211241]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-None-False-sum-c] ______________

dim = 'c', operation = 'sum', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.45325169,  1.72658962, -0.51938878, -0.19008285],
        [-0.454067....14886363]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-None-False-sum-dim3] ____________

dim = ('a', 'b'), operation = 'sum', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.1389001 ,  0.32369261,  0.73684214,  0.07464355],
        [-0.914096....88508354]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-None-False-sum-dim4] ____________

dim = ('a', 'b', 'c'), operation = 'sum', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 1.51860994,  0.42924691,  0.02688617, -1.90793469],
        [-0.794019....3497378 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-None-False-sum-None] ____________

dim = None, operation = 'sum', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 4.89204791e-01,  1.50649133e-01, -2.46983994e-01,
         -9.43908352...18622e-01]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-None-False-mean-a] _____________

dim = 'a', operation = 'mean', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.67547475,  0.02020362, -0.867692  , -2.2768096 ],
        [-0.503727....0471998 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-None-False-mean-b] _____________

dim = 'b', operation = 'mean', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.60498621, -0.73042857,  1.10862229, -1.00128263],
        [-1.617545....55591791]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-None-False-mean-c] _____________

dim = 'c', operation = 'mean', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.55851217, -1.01648958, -0.91305831,  0.18626768],
        [ 0.847061....5322984 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________ test_weighted_operations_3D[False-None-False-mean-dim3] ____________

dim = ('a', 'b'), operation = 'mean', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-1.26641647,  0.49180098,  0.97801099, -0.43656929],
        [ 1.355157....16051091]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________ test_weighted_operations_3D[False-None-False-mean-dim4] ____________

dim = ('a', 'b', 'c'), operation = 'mean', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.05297637, -0.26483293, -0.05142637, -0.711252  ],
        [-1.218963....00185049]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________ test_weighted_operations_3D[False-None-False-mean-None] ____________

dim = None, operation = 'mean', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.50851284,  0.53374802,  2.23735415, -0.69302662],
        [-1.245841....83162401]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________ test_weighted_operations_3D[False-True-True-sum_of_weights-a] _________

dim = 'a', operation = 'sum_of_weights', add_nans = True, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.7121911 ,  0.95834273, -0.62692112,  1.28835287],
        [ 2.021163...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
________ test_weighted_operations_3D[False-True-True-sum_of_weights-b] _________

dim = 'b', operation = 'sum_of_weights', add_nans = True, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 1.32674824,  0.34024606,         nan,         nan],
        [ 0.482072....8407619 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
________ test_weighted_operations_3D[False-True-True-sum_of_weights-c] _________

dim = 'c', operation = 'sum_of_weights', add_nans = True, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[        nan,         nan, -0.77428731,         nan],
        [ 2.063927....37179816]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[False-True-True-sum_of_weights-dim3] _______

dim = ('a', 'b'), operation = 'sum_of_weights', add_nans = True, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.29320396,  1.56065792,  1.19202784, -0.11978756],
        [ 0.998244....64529153]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[False-True-True-sum_of_weights-dim4] _______

dim = ('a', 'b', 'c'), operation = 'sum_of_weights', add_nans = True
skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.11825173,  1.05278258,  0.11787158, -0.05342806],
        [        n....09932479]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[False-True-True-sum_of_weights-None] _______

dim = None, operation = 'sum_of_weights', add_nans = True, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.37483538, -0.83421239, -0.24550025,         nan],
        [-1.837749....21900839]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______________ test_weighted_operations_3D[False-True-True-sum-a] ______________

dim = 'a', operation = 'sum', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.84938045,  1.05471932,  0.49158358,         nan],
        [ 1.343798....29513645]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_3D[False-True-True-sum-b] ______________

dim = 'b', operation = 'sum', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.18339184,  0.4237014 , -1.46764393,  2.08135928],
        [        n....11549534]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_3D[False-True-True-sum-c] ______________

dim = 'c', operation = 'sum', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[        nan, -0.63495558, -0.65246136, -0.62203385],
        [-0.133647...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-True-True-sum-dim3] _____________

dim = ('a', 'b'), operation = 'sum', add_nans = True, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.56274436,  1.25296195, -0.75663856,         nan],
        [-1.240333....5042373 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-True-True-sum-dim4] _____________

dim = ('a', 'b', 'c'), operation = 'sum', add_nans = True, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.29120962,         nan,  0.73164396,  0.83255583],
        [ 0.313314....78379774]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-True-True-sum-None] _____________

dim = None, operation = 'sum', add_nans = True, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[        nan, -1.78061317,  0.90871324,         nan],
        [ 0.956791...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-True-True-mean-a] ______________

dim = 'a', operation = 'mean', add_nans = True, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.24515333,         nan,  0.21484617,  1.75762883],
        [-0.597421...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-True-True-mean-b] ______________

dim = 'b', operation = 'mean', add_nans = True, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.63039275,  0.01480689,         nan,  1.52082497],
        [-1.336263....90788431]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-True-True-mean-c] ______________

dim = 'c', operation = 'mean', add_nans = True, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.80681345,         nan,         nan,  1.62150218],
        [        n....5454979 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-True-True-mean-dim3] ____________

dim = ('a', 'b'), operation = 'mean', add_nans = True, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 6.46746845e-01,             nan, -1.14472877e-01,
         -2.46989430...57545e+00]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-True-True-mean-dim4] ____________

dim = ('a', 'b', 'c'), operation = 'mean', add_nans = True, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[        nan,  1.86876641, -1.55719872,  1.04540949],
        [ 0.292483....70165732]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-True-True-mean-None] ____________

dim = None, operation = 'mean', add_nans = True, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 1.62008482, -1.01569901,  2.07828037, -0.91594619],
        [ 0.921608...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________ test_weighted_operations_3D[False-True-False-sum_of_weights-a] ________

dim = 'a', operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.28300884,  0.22417407, -0.04416997,  0.58496913],
        [ 0.275890....26032799]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
________ test_weighted_operations_3D[False-True-False-sum_of_weights-b] ________

dim = 'b', operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.38797898,  0.03845448, -0.09570131, -0.19886447],
        [ 1.163285....17316128]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
________ test_weighted_operations_3D[False-True-False-sum_of_weights-c] ________

dim = 'c', operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.75206165, -0.48669805, -1.07172032,  0.0130512 ],
        [ 0.071871....31818141]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______ test_weighted_operations_3D[False-True-False-sum_of_weights-dim3] _______

dim = ('a', 'b'), operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.94255317, -0.68945715, -0.32518179, -0.40083481],
        [ 0.216554....59571853]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______ test_weighted_operations_3D[False-True-False-sum_of_weights-dim4] _______

dim = ('a', 'b', 'c'), operation = 'sum_of_weights', add_nans = False
skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.04089608,  1.84761838, -0.79170782, -2.09475288],
        [-0.664150....34748324]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______ test_weighted_operations_3D[False-True-False-sum_of_weights-None] _______

dim = None, operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-1.13859195, -0.5224577 , -0.15405931,  0.90991944],
        [-0.748405....65490499]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_____________ test_weighted_operations_3D[False-True-False-sum-a] ______________

dim = 'a', operation = 'sum', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.39837491,  0.37147526, -1.37020735,  0.03598813],
        [ 0.489123....38480275]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-True-False-sum-b] ______________

dim = 'b', operation = 'sum', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.48843668, -0.35873832,  0.42585738, -1.44209648],
        [ 1.428437....07596704]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-True-False-sum-c] ______________

dim = 'c', operation = 'sum', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.1485941 , -0.16551135,  0.65563096,  1.01165282],
        [-2.456590....21003722]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-True-False-sum-dim3] ____________

dim = ('a', 'b'), operation = 'sum', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.77641731,  0.24571361,  0.13424307, -1.34412395],
        [-0.608362....89699914]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-True-False-sum-dim4] ____________

dim = ('a', 'b', 'c'), operation = 'sum', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.55319386, -0.59276532,  0.55232461, -3.18887861],
        [-0.994556....32740632]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-True-False-sum-None] ____________

dim = None, operation = 'sum', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-2.38644481e+00,  1.00031562e+00,  5.82886140e-01,
          6.89698852...66897e-01]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-True-False-mean-a] _____________

dim = 'a', operation = 'mean', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-1.57914035,  1.7780618 ,  0.66416031,  0.38412305],
        [ 0.943148....30114401]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-True-False-mean-b] _____________

dim = 'b', operation = 'mean', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.86140537, -0.28952683, -0.73668748, -0.21977988],
        [-0.770136....99360097]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-True-False-mean-c] _____________

dim = 'c', operation = 'mean', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.41458564,  0.00332719,  1.57445648,  0.09321954],
        [-1.143376....19252478]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________ test_weighted_operations_3D[False-True-False-mean-dim3] ____________

dim = ('a', 'b'), operation = 'mean', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.04025987,  0.92530828, -0.41651915, -0.70320054],
        [ 0.762943....04548294]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________ test_weighted_operations_3D[False-True-False-mean-dim4] ____________

dim = ('a', 'b', 'c'), operation = 'mean', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.26715948, -0.76138551, -0.4119054 ,  0.42257709],
        [-0.236836....6146554 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________ test_weighted_operations_3D[False-True-False-mean-None] ____________

dim = None, operation = 'mean', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.92680851, -0.57756508,  0.44994217, -0.18918836],
        [ 2.384113....15494712]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________ test_weighted_operations_3D[False-False-True-sum_of_weights-a] ________

dim = 'a', operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.40547193,         nan,         nan, -0.96500512],
        [ 0.638377....31000523]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
________ test_weighted_operations_3D[False-False-True-sum_of_weights-b] ________

dim = 'b', operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-1.40985316,         nan, -0.7042917 , -1.04973919],
        [-1.367893....04339253]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
________ test_weighted_operations_3D[False-False-True-sum_of_weights-c] ________

dim = 'c', operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.4871781 ,         nan, -0.21286732, -0.62802929],
        [-0.581200....11838012]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______ test_weighted_operations_3D[False-False-True-sum_of_weights-dim3] _______

dim = ('a', 'b'), operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[        nan,  0.4149868 , -0.18496937, -2.03577337],
        [        n....24085985]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______ test_weighted_operations_3D[False-False-True-sum_of_weights-dim4] _______

dim = ('a', 'b', 'c'), operation = 'sum_of_weights', add_nans = True
skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.41485737,         nan, -1.52849422, -0.17679499],
        [-0.575851....2422265 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______ test_weighted_operations_3D[False-False-True-sum_of_weights-None] _______

dim = None, operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[        nan,  0.65834463,         nan, -1.57529046],
        [-0.175686....01470993]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_____________ test_weighted_operations_3D[False-False-True-sum-a] ______________

dim = 'a', operation = 'sum', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-7.67796677e-02, -2.06482856e+00, -1.61511184e+00,
                    ...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-False-True-sum-b] ______________

dim = 'b', operation = 'sum', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 8.39831363e-02, -2.40881718e-01,  5.60459208e-01,
                    ...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-False-True-sum-c] ______________

dim = 'c', operation = 'sum', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 1.1232921 ,  0.60751915,         nan,  1.33448834],
        [ 0.463746....12273327]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-False-True-sum-dim3] ____________

dim = ('a', 'b'), operation = 'sum', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-1.92880851e+00, -1.16136625e+00, -6.58893706e-01,
          1.79547792...50834e-01]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-False-True-sum-dim4] ____________

dim = ('a', 'b', 'c'), operation = 'sum', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.29923694,  0.21968085,  0.38092674,  0.20916679],
        [-0.450167....66425114]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-False-True-sum-None] ____________

dim = None, operation = 'sum', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 1.91364555e+00, -7.59938989e-01, -9.66450936e-01,
                    ...38733e-01]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-False-True-mean-a] _____________

dim = 'a', operation = 'mean', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[        nan,  0.12467183, -0.28469429,         nan],
        [-0.504003....26676203]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-False-True-mean-b] _____________

dim = 'b', operation = 'mean', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.56380006,  0.72193987, -0.4475794 ,  0.41033415],
        [-0.271824...      nan]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-False-True-mean-c] _____________

dim = 'c', operation = 'mean', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.70129752,  0.62839693,  0.00326718,  1.61588564],
        [ 0.031739....7651645 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________ test_weighted_operations_3D[False-False-True-mean-dim3] ____________

dim = ('a', 'b'), operation = 'mean', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[        nan, -0.80759692,         nan,  0.82742498],
        [ 0.302189....1781795 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________ test_weighted_operations_3D[False-False-True-mean-dim4] ____________

dim = ('a', 'b', 'c'), operation = 'mean', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-1.35617954, -0.59970153,  1.54708814, -1.58653613],
        [        n....75171502]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________ test_weighted_operations_3D[False-False-True-mean-None] ____________

dim = None, operation = 'mean', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 1.34681821, -0.25166194,  2.51607665,  1.62244941],
        [-0.654711....03601497]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_______ test_weighted_operations_3D[False-False-False-sum_of_weights-a] ________

dim = 'a', operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.91456411,  1.48926324, -0.64259241, -0.25715404],
        [ 0.850449....07505103]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[False-False-False-sum_of_weights-b] ________

dim = 'b', operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.16808419, -0.3174804 , -1.00740735,  0.42191608],
        [-1.663381....01430589]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_______ test_weighted_operations_3D[False-False-False-sum_of_weights-c] ________

dim = 'c', operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.63081507, -1.44361687,  0.43870988,  1.22498301],
        [ 0.755143....16710979]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______ test_weighted_operations_3D[False-False-False-sum_of_weights-dim3] ______

dim = ('a', 'b'), operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.72380466,  1.03650416,  0.85877686, -1.18998256],
        [ 0.631725....31738764]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______ test_weighted_operations_3D[False-False-False-sum_of_weights-dim4] ______

dim = ('a', 'b', 'c'), operation = 'sum_of_weights', add_nans = False
skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.86615632,  1.34776298,  0.72522799,  0.13924169],
        [-0.047040....97471657]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c')

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______ test_weighted_operations_3D[False-False-False-sum_of_weights-None] ______

dim = None, operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = data.weighted(weights).sum_of_weights(dim)

xarray/tests/test_weighted.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 1.19408387,  0.31131181,  0.03784215,  0.50859274],
        [ 0.828606....32802556]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_____________ test_weighted_operations_3D[False-False-False-sum-a] _____________

dim = 'a', operation = 'sum', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-1.25184604, -0.0611957 ,  1.30693659,  0.49466681],
        [-0.708783....0869337 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-False-False-sum-b] _____________

dim = 'b', operation = 'sum', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.6960244 ,  2.63456475, -1.37900691, -0.56512704],
        [ 0.447942....6265574 ]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_3D[False-False-False-sum-c] _____________

dim = 'c', operation = 'sum', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-1.13162969e+00,  7.59011798e-02,  2.29364277e-01,
         -7.00238295...20059e+00]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________ test_weighted_operations_3D[False-False-False-sum-dim3] ____________

dim = ('a', 'b'), operation = 'sum', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-7.75842781e-01,  7.23188725e-01, -1.55750409e-01,
          4.54157858...76321e-01]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________ test_weighted_operations_3D[False-False-False-sum-dim4] ____________

dim = ('a', 'b', 'c'), operation = 'sum', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.08164292, -1.48687884, -2.13937072,  0.82995071],
        [ 2.126651....90399702]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________ test_weighted_operations_3D[False-False-False-sum-None] ____________

dim = None, operation = 'sum', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.02627471,  0.10079941,  0.5909941 , -1.61185367],
        [-0.077422....92374864]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-False-False-mean-a] _____________

dim = 'a', operation = 'mean', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-0.727738  ,  1.64738765,  1.62263946,  0.24077133],
        [ 0.846255....02957044]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'a', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-False-False-mean-b] _____________

dim = 'b', operation = 'mean', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[-1.83190003e+00, -5.14268331e-01, -1.06368481e+00,
         -2.16757448...89636e+00]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'b', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
____________ test_weighted_operations_3D[False-False-False-mean-c] _____________

dim = 'c', operation = 'mean', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 1.10234128e+00, -1.58450528e-03, -5.17935389e-01,
          1.76178866...96514e-01]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = 'c', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________ test_weighted_operations_3D[False-False-False-mean-dim3] ___________

dim = ('a', 'b'), operation = 'mean', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.17169122,  0.68323533, -1.50067487, -0.78954378],
        [ 0.712442....30224434]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b'), skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________ test_weighted_operations_3D[False-False-False-mean-dim4] ___________

dim = ('a', 'b', 'c'), operation = 'mean', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 0.41864947,  0.01096969, -1.00282895,  2.17586057],
        [-0.174070....46980597]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = ('a', 'b', 'c'), skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
___________ test_weighted_operations_3D[False-False-False-mean-None] ___________

dim = None, operation = 'mean', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("a", "b", "c", ("a", "b"), ("a", "b", "c"), None))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_3D(dim, operation, add_nans, skipna, as_dataset):
    
        dims = ("a", "b", "c")
        coords = dict(a=[0, 1, 2, 3], b=[0, 1, 2, 3], c=[0, 1, 2, 3])
    
        weights = DataArray(np.random.randn(4, 4, 4), dims=dims, coords=coords)
    
        data = np.random.randn(4, 4, 4)
    
        # add approximately 25 % NaNs (https://stackoverflow.com/a/32182680/3010700)
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data, dims=dims, coords=coords)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = data.weighted(weights).sum_of_weights(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a, b, c
da = <xarray.DataArray (a: 4, b: 4, c: 4)>
array([[[ 1.57260195,  1.69470057, -0.50857507, -0.72100926],
        [-1.374461....52102525]]])
Coordinates:
  * a        (a) int64 0 1 2 3
  * b        (b) int64 0 1 2 3
  * c        (c) int64 0 1 2 3
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________ test_weighted_operations_nonequal_coords[True-sum_of_weights] _________

operation = 'sum_of_weights', as_dataset = True

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_nonequal_coords(operation, as_dataset):
    
        weights = DataArray(np.random.randn(4), dims=("a",), coords=dict(a=[0, 1, 2, 3]))
        data = DataArray(np.random.randn(4), dims=("a",), coords=dict(a=[1, 2, 3, 4]))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        expected = expected_weighted(
            data, weights, dim="a", skipna=None, operation=operation
        )
>       result = getattr(data.weighted(weights), operation)(dim="a")

xarray/tests/test_weighted.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a
da = <xarray.DataArray 'data' (a: 4)>
array([-0.2173361 ,  1.32568965,  0.08282532,  0.06852599])
Coordinates:
  * a        (a) int64 1 2 3 4
dim = 'a'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______________ test_weighted_operations_nonequal_coords[True-sum] ______________

operation = 'sum', as_dataset = True

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_nonequal_coords(operation, as_dataset):
    
        weights = DataArray(np.random.randn(4), dims=("a",), coords=dict(a=[0, 1, 2, 3]))
        data = DataArray(np.random.randn(4), dims=("a",), coords=dict(a=[1, 2, 3, 4]))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        expected = expected_weighted(
            data, weights, dim="a", skipna=None, operation=operation
        )
>       result = getattr(data.weighted(weights), operation)(dim="a")

xarray/tests/test_weighted.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a
da = <xarray.DataArray 'data' (a: 4)>
array([-1.08846819, -1.7575233 ,  0.86580953,  0.44985825])
Coordinates:
  * a        (a) int64 1 2 3 4
dim = 'a', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_nonequal_coords[True-mean] ______________

operation = 'mean', as_dataset = True

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_nonequal_coords(operation, as_dataset):
    
        weights = DataArray(np.random.randn(4), dims=("a",), coords=dict(a=[0, 1, 2, 3]))
        data = DataArray(np.random.randn(4), dims=("a",), coords=dict(a=[1, 2, 3, 4]))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        expected = expected_weighted(
            data, weights, dim="a", skipna=None, operation=operation
        )
>       result = getattr(data.weighted(weights), operation)(dim="a")

xarray/tests/test_weighted.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: a
da = <xarray.DataArray 'data' (a: 4)>
array([-2.265176  ,  1.24654458,  0.003124  , -0.13988488])
Coordinates:
  * a        (a) int64 1 2 3 4
dim = 'a', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________ test_weighted_operations_nonequal_coords[False-sum_of_weights] ________

operation = 'sum_of_weights', as_dataset = False

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_nonequal_coords(operation, as_dataset):
    
        weights = DataArray(np.random.randn(4), dims=("a",), coords=dict(a=[0, 1, 2, 3]))
        data = DataArray(np.random.randn(4), dims=("a",), coords=dict(a=[1, 2, 3, 4]))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        expected = expected_weighted(
            data, weights, dim="a", skipna=None, operation=operation
        )
>       result = getattr(data.weighted(weights), operation)(dim="a")

xarray/tests/test_weighted.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a
da = <xarray.DataArray (a: 4)>
array([ 1.16025095, -0.48931479, -1.23256076, -0.00432349])
Coordinates:
  * a        (a) int64 1 2 3 4
dim = 'a'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_____________ test_weighted_operations_nonequal_coords[False-sum] ______________

operation = 'sum', as_dataset = False

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_nonequal_coords(operation, as_dataset):
    
        weights = DataArray(np.random.randn(4), dims=("a",), coords=dict(a=[0, 1, 2, 3]))
        data = DataArray(np.random.randn(4), dims=("a",), coords=dict(a=[1, 2, 3, 4]))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        expected = expected_weighted(
            data, weights, dim="a", skipna=None, operation=operation
        )
>       result = getattr(data.weighted(weights), operation)(dim="a")

xarray/tests/test_weighted.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a
da = <xarray.DataArray (a: 4)>
array([ 0.596814  , -1.17730645,  1.1758921 ,  0.51056723])
Coordinates:
  * a        (a) int64 1 2 3 4
dim = 'a', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_nonequal_coords[False-mean] _____________

operation = 'mean', as_dataset = False

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_nonequal_coords(operation, as_dataset):
    
        weights = DataArray(np.random.randn(4), dims=("a",), coords=dict(a=[0, 1, 2, 3]))
        data = DataArray(np.random.randn(4), dims=("a",), coords=dict(a=[1, 2, 3, 4]))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        expected = expected_weighted(
            data, weights, dim="a", skipna=None, operation=operation
        )
>       result = getattr(data.weighted(weights), operation)(dim="a")

xarray/tests/test_weighted.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: a
da = <xarray.DataArray (a: 4)>
array([ 0.27973304,  0.12431191,  0.22822635, -1.06191917])
Coordinates:
  * a        (a) int64 1 2 3 4
dim = 'a', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([        nan, -0.32116606, -0.52920496,  0.17004324])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.24345041,  0.34496878,         nan, -1.78571522])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[        nan,  0.24262336,  0.4496804 ,         nan],
       [-2...       nan],
       [-1.75348462, -0.94989124,  1.84166753,  1.32522863]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.50687414, -0.73193482,  0.67084101,  1.07195522],
       [-2...0.19509017],
       [        nan,         nan, -1.35385054,  1.39039245]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-1.34212505,  1.32552932, -0.53182833,  1.22166944],... ],
        [ 1.3192907 ,         nan,  0.81117193, -0.75335442]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.78293935,  0.45899872,  0.45375426, -0.00485909],...6],
        [ 0.81402285, -1.56365533,  1.12879454, -1.58706728]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([        nan, -0.28617397, -0.01291765,  0.50534561])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([        nan,  1.2636236 ,  1.19012976, -0.52730123])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.10157485,  0.63488354,  0.33731308, -1.38428382],
       [-0...1.74854056],
       [        nan,  0.2701936 ,         nan, -0.16284357]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.39381443,         nan, -0.38600982,  0.42371094],
       [-1...0.03400109],
       [ 0.35879547,         nan,         nan,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.417308  , -1.9651962 ,  1.92579571,  0.83561818],...7],
        [ 0.55165576,  0.02678283,  1.24406335,  0.77669244]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-1.48204892, -0.38909141,  0.28375694,  0.43739432],...n],
        [-0.81498727,         nan, -1.19371712,  0.64997069]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 1.05707911, -0.97769014, -0.30321953,         nan])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.49773861, -0.65731439, -0.30676496,         nan])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 2.06097216,  1.09496715,  1.46917643,  0.72215925],
       [-0...       nan],
       [ 0.60270701,  0.3678175 ,         nan,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 4.12124821e-02,  9.07406681e-01, -2.51906960e-01,
         7.8...29287089e+00,             nan,  2.29040561e-01,
                    nan]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.24457318, -0.26832968, -1.02841438,  0.34316347],...7],
        [-0.66779328,         nan,  0.9806063 ,  0.9300315 ]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[            nan,             nan,  9.22620773e-01,
 ...nan,  1.31138638e+00,  9.85959988e-01,
          6.28455992e-01]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.22050112,         nan,  0.10335723, -0.76905626])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([        nan,  0.36481302, -0.7361875 ,  0.45669503])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-1.61239246,  1.05849443,  1.25150377,  0.37270763],
       [-2...       nan],
       [ 1.61968834,         nan,         nan, -0.31609691]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.86043764,  0.37254801,         nan, -0.36520895],
       [  ...0.73808056],
       [-0.52729075, -0.13619518,         nan,  0.53522043]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 2.2715034 , -0.6698779 , -0.85283021, -1.6673584 ],...8],
        [ 1.16984646,         nan,  0.06023478, -0.03733935]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.34520405,         nan,         nan, -0.16833095],...n],
        [-1.36529617, -0.54401583, -1.04464422, -0.30926284]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([        nan,  1.16597289, -2.00539595,  1.03145697])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([        nan, -0.51446641, -0.83774375, -0.04667979])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[        nan,         nan,  0.0356527 ,  0.70399156],
       [-0...1.35803136],
       [ 0.27929437,         nan,  0.46697257, -0.25842032]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.51509789, -0.17395674, -0.9097752 ,         nan],
       [-1...2.14588066],
       [        nan, -1.6464617 , -0.99075961, -1.87208078]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan, -1.53059375,  2.09599064,  0.13528499],...n],
        [ 0.05535801, -0.32873029,  1.42290028,  0.41015546]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-3.05524202e-01, -2.75546594e-01, -1.82337254e+00,
 ...nan,  8.30374434e-01,  1.41321620e+00,
         -1.84868612e+00]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 0.25660587,  0.19957442,         nan, -1.03406123])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.22253463,  1.79338104,         nan,  1.12154928])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[        nan,  1.60471187, -1.43573934,         nan],
       [ 0...1.61925789],
       [-0.35329062, -0.63353561,         nan, -1.21322308]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[        nan, -0.11386216,  0.52774399, -1.82302601],
       [-1...0.62203022],
       [ 1.51202146,         nan, -2.08635977,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.42767594, -0.17544529,  0.77613547,         nan],...3],
        [-0.69331827,         nan,         nan, -0.94743602]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-sum-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan, -1.23977776,  1.08034211,         nan],...1],
        [        nan, -1.12237792,  0.10365616, -1.25180692]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-mean-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 1.78646189, -1.23685623,         nan, -1.40637546])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-mean-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([0.72856016, 0.14143515, 1.67185565,        nan])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-mean-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.2987082 ,  0.98358681, -0.18041071,  0.12283722],
       [-0...       nan],
       [-1.09738313,         nan,         nan, -1.13993746]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-mean-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[        nan,  0.08147698, -0.32532614, -0.67237051],
       [ 1...1.53162986],
       [-0.33150739,  0.52075417,         nan,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-mean-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.30312017,         nan, -1.62138437,  0.14046117],...8],
        [        nan,         nan,         nan,         nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-mean-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.47187299, -0.42259298,         nan,  1.24878139],...4],
        [-0.56757986, -2.33505403,  0.34619015, -1.53910742]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-mean-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.37685976,         nan,  0.50631025, -0.97936335])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-mean-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([        nan,  0.20574807, -0.20897107, -0.5882138 ])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-mean-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.79418485,         nan,         nan, -0.80556483],
       [ 1...0.80263766],
       [        nan, -0.25716456, -1.07646574,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-mean-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.39532511, -0.83320628, -1.18423112, -0.66459951],
       [ 0...1.08034509],
       [-0.07144649,  0.42548335,  1.60293311,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-mean-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'mean', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.22936751,  1.00940099, -0.29864165, -1.12240259],...2],
        [        nan, -0.44084013, -0.5168837 ,  0.82710426]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-mean-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-2.10397099,  0.78934038,  1.32193347,         nan],... ],
        [-0.60248743,  0.16883786,  0.32938301,  0.16718299]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-mean-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.53726321,         nan, -0.70170065, -0.96541203])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-mean-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.55904107,  1.4899774 , -0.81053556,         nan])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-mean-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-2.31057361,  0.65875444, -0.16407292,  2.32431845],
       [  ...       nan],
       [ 0.68160772, -0.06701979,  0.63349932, -0.44341989]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-mean-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.60737005,  1.95543586,  0.21670605, -0.10896765],
       [ 1...0.43121022],
       [        nan,  0.45065088, -0.55618414,  1.67725984]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-mean-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-1.43535916e+00,             nan,             nan,
 ...-01,  5.00466590e-02, -1.00834537e+00,
          8.69458579e-01]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-True-mean-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = True, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.4203858 ,         nan,  0.08121019,         nan],...9],
        [ 0.11558951, -1.94383753,         nan,         nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 0.82221578,  0.22557062, -1.36124237, -0.37104246])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.18103069, -1.24422544, -0.19614836,  0.76801162])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.54409198, -0.10470926,  0.86035731,  0.273566  ],
       [ 0...1.41462432],
       [ 1.58030006,  0.77558384,  1.64949144, -0.301041  ]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.47274847, -0.17160902,  0.57000197,  2.04724868],
       [ 0...2.06829591],
       [ 0.14604738, -0.80166521,  0.02913582, -0.36971997]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.73704824, -1.26123187, -1.05767889,  2.70811584],... ],
        [ 0.06854953,  1.056398  , -1.11585539, -0.03040968]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.50327655,  0.12740422, -2.52189997, -0.54301087],...2],
        [ 0.1459072 ,  0.07353297,  0.9299842 ,  1.1756735 ]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([1.35808547, 0.00269899, 0.52686917, 1.31211132])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.39957457,  0.5871034 ,  2.72275481,  1.37779396])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-1.03664535,  0.71807986,  0.38580808, -0.93943863],
       [-0...0.08978366],
       [ 0.27768157,  0.48699038, -1.46960274,  0.13900158]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-1.27734844, -0.05312052,  0.63703923,  0.16016389],
       [ 0...0.89074934],
       [ 1.26157187, -0.55563483, -1.0535064 , -2.06690205]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.37853174,  0.72052241, -0.65762473, -1.09441888],...9],
        [ 0.19743523,  0.19630414,  0.25563646, -1.78188488]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.00559824,  1.37019365, -0.19937871, -0.09561126],...6],
        [-0.16414221,  1.11467296,  0.13677689, -0.83140316]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.6776125 , -0.74088289, -0.50983918, -0.68052542])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.50117738, -1.54771225,  0.28590066,  0.92365987])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.57690009,  0.80493108, -0.48113587,  1.51439492],
       [-0...0.18109667],
       [ 0.20336901,  0.47652433, -3.08750101,  1.04397323]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 1.19125652,  0.65441245,  0.2447777 , -1.71770479],
       [-0...0.90917468],
       [-0.81391749,  0.23955911, -0.20824411, -0.29158797]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.11786361,  1.36349961,  1.19926586, -0.42383413],...5],
        [-0.04265416,  1.36754121,  0.92169426, -1.30557976]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.23450739,  0.00291236,  0.86858316, -0.89193596],...1],
        [-0.90038076,  1.17537101,  0.18702353, -1.53535407]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 0.71772796,  0.16935516, -0.08135787,  0.27358275])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.58324667, -1.44622079, -0.30700453, -1.0749816 ])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.5836999 ,  0.04829813,  0.43483648, -0.01720429],
       [-2...0.88117082],
       [ 0.72526879,  1.95150437, -1.16230288, -0.25726913]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.66239334, -1.8637704 , -0.87474996,  1.30008021],
       [-0...0.94665075],
       [ 1.72303492, -0.58966744,  0.20707221,  0.05019999]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-1.3654332 ,  0.66542843,  0.10173679,  0.83451828],...4],
        [ 0.13804275, -0.44718391, -1.44346848,  0.22738159]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.21829234,  0.40022557, -1.17065511, -0.27486518],...4],
        [ 0.67090673,  0.1807809 , -0.98820703, -2.55599219]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.18378447,  0.77992676, -0.5814423 ,  0.70550116])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 2.10111517,  0.35440622,  1.33032924, -0.07575028])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 1.02273788e+00,  5.60782828e-01, -1.46292857e-01,
        -7.4...86820313e+00,  1.58909101e-04,  2.71142668e-01,
         3.93526856e-01]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-9.59906094e-01,  8.74387110e-01,  1.19131820e+00,
         4.4...48597564e-01, -1.89473091e-01, -1.71203957e-03,
         7.47420490e-02]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.97957384, -0.025453  ,  1.27667159, -0.59599494],...5],
        [ 0.28549421,  1.44724976,  0.16319808, -1.00424965]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.07615687,  0.32760978,  0.12583315, -1.16045471],...6],
        [ 0.38159869,  0.39543422, -1.35698504,  0.56813923]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-1.12854732,  0.13260706,  0.0602911 , -0.21933626])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 1.62064084, -0.52910719,  0.22933581,  0.43773529])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.71455814, -0.03305623, -0.27684503, -1.62965907],
       [-0...1.4314239 ],
       [ 0.64018224, -0.29745742,  1.10890565,  0.36674763]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.60424944,  0.8200946 ,  0.41587441, -0.13423235],
       [-2...0.55160776],
       [ 0.24554309, -1.98696458, -2.35599817, -0.72347646]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-1.69564897,  0.472641  , -1.13933846, -0.13440011],...4],
        [ 0.96154347, -0.28645164,  1.20107021, -0.55279811]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-sum-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.73736169,  1.61307222,  0.74114858,  0.76000879],...4],
        [-0.55977194, -0.2695933 ,  1.28043924,  0.93032225]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-mean-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.18317449,  0.87622102, -1.65743857,  0.82753455])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-mean-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 0.82283561, -1.79141231,  0.97968902, -0.32066672])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-mean-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 1.17608674,  0.07913437,  0.23998397, -0.3473954 ],
       [-0...0.16108163],
       [-2.88375578,  1.32231744,  0.93460359,  0.97830103]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-mean-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.71588999,  0.75043773, -1.15798103, -1.01982054],
       [ 0...0.39256101],
       [ 0.57478569, -1.54597444, -0.54443942,  0.84030061]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-mean-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.14496327, -0.49216203,  1.17573993, -0.39176103],...8],
        [ 0.75766694,  1.41347001, -1.07864135, -0.86387638]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-mean-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.10540877,  0.01016664,  0.2392933 , -1.81772822],...3],
        [ 0.22661469,  0.77527236,  1.89026735,  1.73496742]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-mean-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.13111723,  1.6602588 , -0.22029917, -0.48539652])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-mean-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 5.94161993e-01,  4.86150625e-01, -1.22717301e-01, -2.18483943e-04])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-mean-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 1.85107472, -1.24637496, -0.07958698, -1.89020793],
       [-0...0.95851913],
       [-0.4531608 ,  0.83816002,  0.49813069,  0.01588654]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-mean-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.33227256, -1.96889843,  0.27053286,  0.3783599 ],
       [ 0...1.02832956],
       [ 0.03687161, -0.02611552, -2.63652152,  1.70124599]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-mean-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'mean', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.12911159,  0.31169003,  1.35177489,  2.03958565],...7],
        [-1.65466088,  0.91258286, -1.52787773, -0.2248186 ]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-mean-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.73098882, -2.01702654, -0.21795189,  1.07081122],...3],
        [-1.61459852,  0.08292879,  2.46279193, -0.39877381]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-mean-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.13465553, -0.8992948 , -0.72602104,  0.69842323])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-mean-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([2.00144309, 1.53516818, 0.56201892, 0.08970683])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-mean-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.32045702,  0.26947094, -1.96499517,  0.11196103],
       [-0...0.79135801],
       [-0.15633124, -0.93521059, -0.43711123, -2.48644082]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-mean-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.64978676,  0.61252809,  0.94576355, -1.33205733],
       [ 0...0.75654451],
       [-0.52102787, -0.74204607, -0.5507987 , -1.1890615 ]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-mean-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.49286622, -0.72020255, -1.06358103, -0.98603309],...2],
        [-1.5919326 ,  1.17418262,  0.87503395,  0.74104841]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-None-False-mean-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = False, skipna = None, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.30748712,  0.11967351, -0.30732129, -0.41848801],... ],
        [ 0.566636  ,  0.35614787, -0.71531622,  1.12816143]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([0.32487476, 0.13300661, 0.96950826,        nan])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.26793386,         nan,  0.24108168,  0.73364852])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.86936631,         nan, -0.5431033 ,  1.66520462],
       [-2...       nan],
       [-1.69570424,  0.91089525,         nan, -1.20640676]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.45489486,         nan, -1.31357745,  1.11839194],
       [-0...0.51457304],
       [ 1.30860078, -0.65670988,         nan,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.47089355,  1.00720616,         nan,  0.53067208],...n],
        [        nan, -0.10584893,         nan, -0.20897985]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan,  0.69614789, -1.1938354 , -0.58039411],...n],
        [-0.32637991, -1.55303643,  0.17175027, -1.73050214]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.02457234, -0.85443018,         nan,  0.14127186])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([        nan, -0.3616819 , -0.52004648, -0.4177433 ])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[        nan,  0.599182  , -2.18238328, -0.71996309],
       [-0...1.47502086],
       [        nan,         nan,  1.01696861, -1.40238563]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-1.72308632,  0.22594279,  0.30713033,  0.26707266],
       [ 0...       nan],
       [ 1.52647114,  2.03460486,  1.00972595,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan, -1.66098931, -0.30018522, -0.66411586],...n],
        [ 0.21065551,  0.11660312,  0.45048829,         nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.25284294,  0.67898337,  1.03855973,         nan],...n],
        [ 1.17139469, -2.05186881, -0.81942872,  0.11839111]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([0.35648922, 1.25383366, 0.14969283,        nan])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([0.14761739, 0.22210903,        nan, 0.00314383])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.17861777,         nan, -0.94033277,  0.34130915],
       [ 0...0.81248668],
       [ 0.43495523,  0.00831516,         nan, -1.68279548]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[        nan,         nan,  0.70708893, -0.0030936 ],
       [-1...1.28260175],
       [        nan,  0.36151054,  0.67816319,  0.88520849]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.15008332,  0.91031553,         nan,  0.80252101],...3],
        [ 1.99105592, -0.6072047 , -0.00975796,  0.54568284]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.14239002,  1.66231073, -0.10220105, -0.41539969],... ],
        [        nan, -0.00617387,         nan,         nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.25035865,  0.63951743,         nan,  0.89536551])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([        nan, -0.7493208 , -0.73307175,  1.23973223])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.48011634, -0.03321904, -0.42479416, -1.31614798],
       [-1...       nan],
       [-1.05889648, -0.29216407,         nan, -0.09739407]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.68489336,         nan,  0.8276242 ,         nan],
       [ 1...0.74910176],
       [        nan,  2.23910997, -1.02598814, -0.69357775]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 3.98683667e-03,  6.56243051e-01,  1.33722973e+00,
 ...-01,  1.58215920e+00,  1.36848972e+00,
         -2.74202885e-01]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.79082781, -0.26437121,  0.4618391 , -0.24670773],...8],
        [        nan,  0.17605732,         nan,         nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 1.10082653, -1.40824202,  0.24300603,         nan])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-1.05166295, -0.98580912,  0.81849349,         nan])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.30989439,  0.25009213,         nan, -1.02576419],
       [ 1...       nan],
       [        nan, -0.74467269,  0.75902991,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.93869995,  0.05511804,  1.96587965,         nan],
       [ 0...       nan],
       [-0.27044571,  0.02632441,  0.80852617,  0.80529815]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-1.55340687,  1.08426041,  1.0618997 , -0.2303516 ],...9],
        [ 1.63502118,         nan, -0.26411736, -0.84415929]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.39369482,  1.08453832, -0.26825367,  0.36872206],...9],
        [        nan,         nan,  0.82862142, -0.79682922]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-2.27227369, -0.8613587 ,         nan,  0.34072125])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([        nan, -0.94128023,  0.90803456,  0.2958675 ])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[        nan,  0.32793572, -1.57893927,  0.23323067],
       [ 0...0.52494733],
       [-0.07449629, -0.14744729,         nan,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.80397359,         nan,         nan, -0.20790709],
       [ 0...0.09993532],
       [-1.18839397,  0.24983083,  0.1107171 ,  0.0590754 ]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 2.25515079,         nan,         nan,         nan],...n],
        [ 0.6285329 , -0.20776251,  0.59110807,  2.23819908]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-sum-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.36688618,  0.57447794,  0.18207876,         nan],...1],
        [-1.28390604, -0.13363425,         nan, -0.03097851]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-mean-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-1.02471346, -0.07663924,  0.33653776,         nan])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-mean-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([        nan, -1.36996029, -0.16553128,  0.18887177])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-mean-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-1.31732488,  0.1051693 , -2.07472543, -0.19745305],
       [-0...0.72407477],
       [ 0.59022103,         nan, -1.45382225, -0.68408144]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-mean-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 1.09269981,         nan,  0.04914422, -1.18402017],
       [ 0...0.78648668],
       [ 0.15235769,         nan,  0.19488267,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-mean-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.82563626,  0.72459734, -1.90224944,         nan],... ],
        [ 0.18138553,         nan, -0.17801679, -0.16811798]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-mean-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan,  0.95045682, -0.95433025, -0.38409499],...n],
        [ 1.34666275,  0.79901725,  1.45468318, -0.05280944]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-mean-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.07250785,         nan, -1.15608542, -1.77150353])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-mean-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-1.64458625,  0.83429172,  0.5546443 ,         nan])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-mean-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.56723066,  0.41005394,         nan,  0.62149227],
       [ 1...1.73329633],
       [        nan, -1.25959459, -0.21772665, -0.83603753]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-mean-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.56328723, -1.16289985,  0.70070602,         nan],
       [ 0...2.27132365],
       [        nan,  0.30680202,  1.23175793, -0.60637745]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-mean-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'mean', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.72449928,  0.56885018,  1.44425392,  1.08227247],...1],
        [ 0.92741795,  0.30915209,         nan, -0.88146171]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-mean-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.45257561,         nan, -1.15424559,         nan],...3],
        [ 0.52948903, -0.30747348, -0.9069668 ,  0.07550413]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-mean-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-2.1089199 , -0.37356059,         nan, -0.54364235])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-mean-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-1.54278612,         nan,  0.0019492 ,  1.34325923])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-mean-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 1.14578657,  0.69295341,         nan, -1.42598253],
       [-0...0.21703781],
       [        nan, -0.19031449, -0.84631432, -0.84313213]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-mean-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 1.40975388,  0.86816474,  1.61260269,  1.46850265],
       [ 1...       nan],
       [        nan,  1.52044792,         nan, -0.08036978]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-mean-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.38130068,  2.1850351 ,         nan,         nan],...n],
        [-0.71865236, -0.67712251,  0.7571029 ,  1.16078576]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-True-mean-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = True, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 2.02534694,  1.10665043,         nan,  0.76466338],...5],
        [ 0.67758187,         nan,  0.52622613,  0.60484522]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.19905728,  1.60020722, -0.29794061, -1.09068103])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.75768847,  0.24104069,  0.66327405, -2.39108074])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.1366988 ,  0.03392546, -0.48947772, -0.7622213 ],
       [ 0...0.04774887],
       [ 0.59451076,  1.38197977,  0.57829724, -0.05186448]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.71372046,  0.71613533, -0.28956302,  0.8360063 ],
       [ 0...0.95606686],
       [ 2.02665012, -0.57393605,  0.29991085,  0.15401643]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.55812518, -0.16118641,  0.13281676, -2.88520362],...2],
        [ 1.7074603 , -0.5348562 , -0.061963  , -2.31517495]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.06219922, -0.87207045,  0.20959712, -1.09638913],...5],
        [ 0.0618743 , -1.53305423,  1.33808455,  2.28186239]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([0.05531056, 1.0996547 , 0.33810694, 0.53019221])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 1.83942261, -1.897265  ,  0.49952297, -0.24363031])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.05382671, -0.03957723, -0.03808402,  1.15102665],
       [ 0...0.30924878],
       [ 0.28229507,  0.79636214, -0.93430869,  0.48947627]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.85616609, -0.03499641, -0.29143919, -1.54942032],
       [ 0...0.94613827],
       [-1.08437801, -1.36515543, -0.18979239,  1.10271726]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.93835697,  0.54838942,  1.006751  , -0.45932326],...8],
        [ 0.60867959,  1.44434692, -0.46498658, -0.94950723]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.49721112, -0.18361589,  0.4340766 ,  1.16290819],...8],
        [ 0.711751  ,  1.55285704, -0.53676486, -0.41239365]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 0.79871575, -0.40146467, -0.38345117, -0.53512661])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.29676954,  0.05858812, -1.54433519,  0.23788256])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 1.58048474, -0.42429808,  0.93875114,  1.82194591],
       [-2...0.23864392],
       [ 0.46602424,  0.33039889,  0.77412752, -1.31370425]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-1.17577079, -1.48141759, -0.67596595, -2.89187678],
       [ 1...0.82048671],
       [-0.39059004,  0.70484408, -0.32578655,  0.17065667]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.61683896e-01, -6.22682696e-01, -3.26240890e-01,
 ...-01, -5.08053797e-01, -6.01318914e-01,
          1.04087571e+00]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.13854214,  0.39805931, -2.1181949 ,  1.58636116],...8],
        [ 0.09598539,  1.31642785,  0.08171808,  0.76515079]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([0.07297402, 0.06079182, 0.44171836, 2.23050118])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([0.1468593 , 1.67039573, 0.03125194, 2.19693688])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-1.11875553,  1.03134056, -0.37827748, -0.72779789],
       [ 0...0.64745206],
       [-0.47766072, -1.11253706,  1.16763015,  0.70250575]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.81701472, -0.29667576, -0.33964473, -1.3512068 ],
       [ 0...2.10470203],
       [-1.35505949, -0.73008496,  0.48651971,  0.67848091]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.36677129, -1.42871862,  0.7767277 ,  0.09290798],... ],
        [ 0.03703753, -0.33107481,  1.04446317,  0.11075953]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.03087869, -1.08312023, -0.46701771,  0.15166415],... ],
        [ 1.74740101,  0.13076074, -1.59659519,  1.20121468]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([1.06646809, 0.52696417, 1.4918894 , 0.0755873 ])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-2.21610405, -0.12016001,  0.42534626, -0.53231458])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.27117398, -1.08913213, -0.00396751, -0.60637413],
       [ 0...0.2045203 ],
       [-3.57970608,  0.14292204, -1.18054176, -0.84151863]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.18903496, -0.06839467,  0.8871406 ,  1.1728649 ],
       [ 1...0.25955665],
       [-0.83916834, -0.01563692,  0.90231755,  0.02178412]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.80199946, -1.73260567,  1.10248543, -0.41941385],...7],
        [ 0.4563643 ,  0.1387632 ,  1.73404808, -0.13846525]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-1.08159177,  0.52777926, -0.03175614, -0.71930032],...5],
        [ 0.72906452, -0.41498318, -0.20252216,  0.42137285]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.69716883, -0.3806247 ,  0.47373347, -1.55102447])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.34952265, -0.69971273, -0.01096728, -0.96543275])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.07449479, -1.85672903,  1.24112592,  0.40037342],
       [-0...0.34570167],
       [ 0.89549362, -1.33603722, -0.16696218, -0.66471444]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.37972105,  0.35896109, -0.56082655, -1.24676024],
       [ 0...0.13915154],
       [ 2.2145451 ,  1.23551669,  1.54309056,  1.27365775]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.21266396, -0.31555277,  1.25496581,  0.0883236 ],...6],
        [-0.45063919, -0.3282296 , -0.15406072, -0.63861432]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-sum-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.43178203, -0.349124  ,  1.02684818, -0.86900938],...3],
        [ 0.83946402,  0.74238155, -0.77548644,  0.20118188]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-mean-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-1.15153203, -1.74171639,  0.682653  , -0.49989552])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-mean-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 0.47496107, -0.84121764, -0.84732569, -1.01776661])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-mean-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 6.13413344e-01,  1.67782265e+00,  1.17336276e-03,
        -6.2...82379674e+00,  1.26845473e+00, -4.60260924e-01,
         3.91746781e-01]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-mean-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.92028421,  0.47252984,  1.59319528,  0.20927765],
       [ 0...0.47816248],
       [ 0.43923887,  0.03868099,  0.74025867, -1.97323255]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-mean-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.779863  , -1.54743617, -0.80530313, -0.28674265],...9],
        [ 1.37616324,  1.45272843, -0.16145235,  1.29094989]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-mean-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.87454996, -0.14148994, -1.07723776, -0.34084326],...6],
        [ 0.10806791,  0.80911487,  0.99232298, -0.41525499]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-mean-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 1.95565967,  0.41998589,  1.09190892, -1.43983351])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-mean-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.02210336,  2.11159946, -0.11518936,  0.16761443])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-mean-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.98748512, -1.09673126, -0.41549421,  0.12175146],
       [ 2...0.8417987 ],
       [ 0.99889637,  1.69212579, -0.25734669, -0.51919529]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-mean-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.4257808 ,  0.21297439,  1.54849541,  0.12175291],
       [-0...0.60043703],
       [-0.83017873, -0.78589985,  0.25577018, -1.49842011]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-mean-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'mean', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.17967374, -0.17915637, -0.73875212,  0.37323578],...1],
        [-1.45543851,  0.45631003,  0.98736737, -0.97752264]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-mean-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-1.23188568, -0.31941769,  0.90258064,  0.03300354],...8],
        [ 1.04219128, -0.13545934,  0.35610639, -0.17455067]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-mean-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([0.34933176, 0.27217722, 1.56535078, 0.65042846])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-mean-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.48721768, -1.11313974,  1.14677877,  0.94749249])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-mean-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.47283232,  2.63525711,  0.04549957,  0.84868634],
       [ 1...0.69076866],
       [-0.52133904,  0.17583645, -1.42076355,  1.05599639]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-mean-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.62664894,  1.37671585, -0.77592234, -0.65330145],
       [ 0...1.42611744],
       [-0.42644402, -0.71868822, -0.50619626, -1.21560615]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-mean-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.20583279, -1.32159251,  1.38692382, -0.99482261],...2],
        [-1.36975458,  0.1049505 ,  0.59764233,  0.30599017]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-True-False-mean-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = False, skipna = True, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.99761869, -0.94383355, -0.65241052,  1.51061668],...6],
        [ 0.37539554,  0.64614477, -0.88738612, -1.74082997]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 1.80862473,         nan, -1.58219548,  1.56561411])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([0.55623018,        nan, 0.18715066, 0.60067184])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 1.07367488,         nan, -0.22884034,         nan],
       [  ...1.96225664],
       [-0.83973745, -2.77493966,  0.56123354,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.26045939,  0.73877213, -1.81573427,         nan],
       [ 0...0.92405861],
       [-1.12355662,  0.47332681, -1.27055088, -0.13729585]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan,  0.05610118,         nan, -1.13382645],...2],
        [        nan, -1.76049205,         nan,  1.33115518]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.92302534,  0.11647808,  0.67919178,         nan],...n],
        [-0.41536402,  0.28843309,         nan,         nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-1.60694685, -0.40102667,  0.02584536,         nan])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([        nan, -0.50751441,  0.96489045, -0.86249439])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.69095028,  0.1925229 ,  0.2457967 , -1.33920674],
       [ 0...       nan],
       [        nan,  0.03669981,         nan, -1.55795965]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[        nan,  0.20713259, -0.42422242,  0.53601709],
       [-0...       nan],
       [-0.29130553,  2.49465576,  0.02525127,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 2.06760106,         nan,  0.0668495 ,         nan],...9],
        [ 1.61557932, -1.10132956, -0.7051958 , -1.13027942]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.29988417, -0.03475541,         nan,         nan],...6],
        [-0.98575031,         nan, -0.91551395,  1.18701279]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 1.10594441, -1.41427804,  1.47806217,         nan])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-1.36637648,         nan,  0.36329183,  1.46332847])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-1.32735327,  0.22121588,         nan,         nan],
       [-1...0.45099598],
       [-0.7183813 ,         nan, -1.36890191,  1.26966238]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.73414175,         nan, -0.94178842,  2.93907533],
       [-0...0.28165718],
       [        nan,  0.46134116,         nan,  0.32106151]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-2.19059348,         nan, -0.62612945,         nan],...6],
        [-1.17304705,  0.19250497,         nan, -0.46570213]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan,         nan, -0.9165236 , -0.7042237 ],... ],
        [ 1.78511295,         nan,  0.87945971,         nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([        nan, -0.17522314, -1.35099946, -0.70646288])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 1.7226037 , -1.15780311, -0.86520838,         nan])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.74141473,  0.63636603, -1.03425728,         nan],
       [ 1...       nan],
       [        nan,  0.1738015 , -0.95895315, -0.89157826]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.26284874,  0.38950307,  0.27857663,  0.67515776],
       [ 1...       nan],
       [-1.72123783, -2.10729414,         nan,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.31386237,  0.41163527,  1.05256451, -0.4515465 ],...4],
        [        nan, -0.80403597, -0.77787138,         nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.08959895,         nan,         nan, -1.24522437],...3],
        [ 0.14029918,  0.22826816,         nan, -0.26629508]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.91142746,  0.60529031,         nan, -0.13345598])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([        nan,  2.10908489, -1.22661696,  0.81270332])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[        nan, -0.03865677, -0.63002286, -2.17594013],
       [-1...1.24601984],
       [ 0.33314443, -1.71111616, -0.69800675,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.93224888, -0.93728537, -2.29877241,         nan],
       [-2...       nan],
       [        nan, -1.35167379, -0.05072628, -1.1204443 ]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.35002317,  0.63441083,  0.27405115, -0.37010053],... ],
        [-1.04193612,  0.99868869, -0.40668688,         nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.47951505,  1.19058576,  0.20663958, -0.11128504],...7],
        [-0.64281895,  1.90420894, -0.22800572, -1.42519901]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([        nan, -3.44255554,  0.49421121,  1.17515978])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([       nan, 1.35803871, 1.14713729, 1.52219564])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.40932449, -0.14382724,         nan, -1.15658747],
       [  ...0.20952132],
       [-1.47453839,  0.23375659, -1.08198994,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[        nan,  0.29854568,  0.56928796,         nan],
       [ 0...0.88205108],
       [-1.19012246, -0.08121693,         nan,  0.53664445]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan,         nan, -0.16338522, -1.73455132],...8],
        [ 0.66493598,  0.19807353,  0.63328562,         nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-sum-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan,         nan, -0.13489459, -0.37728012],...6],
        [-0.35698105,  0.43798843,         nan,  0.1981677 ]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-mean-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-1.85570755, -0.33150074,         nan,  0.35709646])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-mean-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([1.82374748, 1.96599316,        nan, 1.53453581])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-mean-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.46487947,  0.89036959,  0.70032054,         nan],
       [  ...0.75433576],
       [ 0.43332443, -1.1254529 , -0.46120257,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-mean-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-1.43099285, -1.15980883,  1.16093673,         nan],
       [-0...1.08026766],
       [        nan,  1.2568781 ,  0.65105432,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-mean-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.15586366,         nan,  0.22457494,         nan],...2],
        [        nan,         nan, -0.2458502 ,  0.0340914 ]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-mean-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.20134255,         nan, -0.10952588,         nan],...n],
        [ 0.61632165,  0.27449619, -0.39442307,  1.90302027]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-mean-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 1.19974165,         nan, -0.72450881, -0.3154306 ])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-mean-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 1.46423897,         nan, -0.62508768,  0.58807866])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-mean-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-1.99861318, -0.68911756,  0.10992108,         nan],
       [  ...0.24320527],
       [-1.73598498,  0.09049941,         nan,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-mean-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.04804927, -0.40041347,         nan,         nan],
       [-1...0.59690365],
       [-1.0027927 ,  0.59395609, -0.75989947, -0.27855546]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-mean-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'mean', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-2.42011210e+00,  1.34548750e+00,             nan,
 ...nan,  6.88443534e-01,             nan,
          4.85751457e-01]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-mean-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan,  0.7256687 ,  1.42573462, -1.46962738],...8],
        [        nan, -0.33030118,  0.55157051, -0.25276132]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-mean-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.63004654, -0.08956428,  1.69677908,         nan])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-mean-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.2321645 ,  0.89208316,         nan, -0.82222256])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-mean-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.63888886,         nan,  1.50973753,         nan],
       [ 0...1.26438897],
       [ 0.58181627,  2.49581766,  0.42095179,  1.08477554]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-mean-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.0542973 , -0.61937498, -0.66410334,         nan],
       [  ...0.21045743],
       [-0.075532  ,  0.24690197, -1.10404159, -0.75264567]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-mean-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-2.14519427,  0.2704571 ,  1.47055828,  0.65967076],...4],
        [        nan,  0.20878   ,  0.48062327, -1.16097603]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-True-mean-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = True, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.63846087, -0.15094322, -0.16764306,  1.60056018],...n],
        [-0.40864113,  1.32901125,  0.21981516,  0.61057696]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.0849544 ,  0.41681942,  1.33590256, -0.55056326])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.1843214 ,  0.89558083, -0.18297136, -0.77295238])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 1.43978345, -0.05082647, -0.85828259, -0.41420169],
       [-0...0.86036062],
       [ 0.00846392,  1.40294209,  1.69629645,  0.47582609]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.83718881, -0.17270553,  1.56415211, -0.6526804 ],
       [ 0...0.30077655],
       [ 0.15387218, -0.08141519,  1.08549686, -0.52763465]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.48692724,  0.71521165,  0.25207367,  0.56553592],...3],
        [ 1.08441621,  0.86387893,  0.45832575, -0.5350477 ]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.40841357,  0.60864635,  0.42374325, -0.80134892],...5],
        [ 1.32638481,  0.79882138, -0.16732879, -0.24475001]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([1.26464136, 0.53537361, 1.34479999, 0.61874931])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.82243286, -1.32857957,  0.91911135,  2.10773719])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.34405909,  0.63788041,  0.23073428,  0.77300942],
       [-1...1.27345205],
       [-0.27240305,  0.64990747,  0.13548881,  1.29641175]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.20266847, -0.18477819, -0.74799552,  0.28896459],
       [-0...0.55262413],
       [ 2.47002472,  0.30183561, -0.0403351 , -1.37800381]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.10974628, -1.09566052, -1.0161029 ,  0.28616957],...5],
        [-0.23136821, -0.06852424, -0.85626248,  0.16565585]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.97555061, -0.89716994, -0.75939668, -0.10471445],... ],
        [-0.61534242,  1.92116301, -0.4020426 ,  1.00430313]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 0.80543188, -1.65779892, -0.49310956,  1.7604953 ])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 2.01392233,  0.06065826, -0.44563282, -0.95708304])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.06415879,  0.528608  ,  1.05396738,  0.60432403],
       [-0...0.30045161],
       [ 0.20921207,  1.0557564 ,  0.52084139, -1.25862907]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-1.34029848, -1.30614378, -1.0774259 ,  0.00303201],
       [ 0...2.03231866],
       [-0.41291641, -0.00493188, -0.15785862,  0.78305485]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.12742616, -1.25041582, -0.31963136, -0.17249642],...1],
        [ 1.66667089, -1.26244269,  0.20092488,  1.38758314]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.0084456 , -0.19905675,  0.9234795 , -1.04992652],...4],
        [-1.11765113,  0.02074518, -1.0818737 , -0.80885858]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.24615042, -0.86025338,  1.24731048,  1.06622543])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([0.66354262, 0.68511511, 1.14891343, 1.19622513])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.54097071,  0.68690034,  0.08642931, -1.4811713 ],
       [-0...0.01361672],
       [ 0.02434448, -1.29180939,  0.84591376, -1.10500655]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 0.13200515,  1.01391473,  0.88029302,  0.50399753],
       [-1...1.20201837],
       [ 1.26741085, -0.41731319,  1.20026787, -0.34800521]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.61172644, -0.12805264,  0.50848672,  1.30171545],...2],
        [-0.33186196, -0.98338621,  0.1213094 ,  1.73555302]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.28939646,  1.93552593, -1.30317894, -1.02217022],...9],
        [ 0.96104418,  0.39347988,  0.20238402, -1.00582159]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.5906791 ,  1.42360049,  1.43591484,  0.29606034])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.03522345,  1.92313787, -0.22290208,  1.48451178])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.16178702,  0.62548324,  1.27849251,  0.32226456],
       [-0...0.05234589],
       [ 0.53097827, -0.34425641,  0.17908631,  0.39773623]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 1.43134539, -0.17054203, -0.63821702,  0.36268938],
       [-0...0.0858203 ],
       [ 0.63170137,  1.16858501, -0.48275637,  0.24736983]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.09267339,  0.35663537, -0.31555593,  0.42318764],...2],
        [ 0.1991472 , -0.73562558, -0.04753482, -2.13116298]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 2.53012706, -0.70193437, -0.54127646, -1.35171628],...4],
        [-0.49338259, -0.12180351, -2.03266707, -1.34140599]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 0.74050803,  0.86317761, -0.51185959,  1.26596615])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.51447413,  0.40037063,  1.00738583, -0.88920624])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-1.37713791e-03,  1.37388460e+00, -1.16577208e+00,
        -7.0...24073408e-01, -1.61162529e+00,  8.26514189e-01,
        -2.59535222e+00]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.21462921, -1.99083524,  0.02861465, -1.74684961],
       [ 0...0.71563086],
       [ 1.21358438,  0.19672277, -0.92356324, -1.22434824]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum', add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.69608378,  0.96102643, -0.81913515,  0.16501419],...4],
        [-0.26680983, -0.48452931,  0.76680473,  0.49778783]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-sum-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.68197899, -0.94175847, -0.45117489,  0.64147492],...8],
        [-0.11906377,  0.62297575, -0.33297057, -1.43141953]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-mean-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 0.62972988,  0.12488083, -1.08146562,  0.39757123])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-mean-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.09026756,  0.18828952,  0.73307893, -1.38292571])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-mean-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-3.58359588e-01, -1.64054264e+00, -9.79938511e-01,
         1.6...83882044e-01,  9.20950753e-01, -1.79315586e-01,
        -5.26700157e-01]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-mean-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.48585033, -0.68996299, -0.57216431,  0.02498181],
       [ 2...0.69785753],
       [ 0.05297309,  1.03758089, -1.97862963,  0.03478469]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-mean-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-2.41162364, -1.57364117, -0.58001498,  1.1742021 ],...8],
        [-1.32976767, -0.61418385, -0.8437814 ,  0.28020419]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-mean-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.55731231,  0.8593771 , -0.85343334, -0.83867157],...9],
        [-1.0104416 , -2.09723983, -2.39070225,  0.87429235]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-mean-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 0.49214335,  0.77553192, -0.62807661,  3.08027048])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-mean-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.05861568, -0.69244141,  1.44040704, -1.60578049])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-mean-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-1.34975814, -0.3397385 ,  0.95664805,  1.81469342],
       [-0...0.50269068],
       [ 0.25125879,  0.82228036,  0.53089313, -0.75527909]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-mean-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.17307839,  1.52858646, -1.25856299,  1.87509867],
       [-0...0.01112557],
       [ 0.09339123, -1.34990961, -1.83168385, -0.50961075]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-mean-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'mean', add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.63047271,  0.44769477, -0.0203946 , -2.19518005],...5],
        [-0.29518413,  0.76966502,  0.07018005, -0.87774047]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-mean-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.02546745,  1.19988859, -0.15874427,  0.65717479],...1],
        [ 0.91997029, -1.80127665,  0.73243645,  0.69264794]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-mean-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([-0.27959323,  1.15410802, -1.26248698, -2.20504785])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-mean-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4)>
array([ 0.75275266, -1.24437689,  0.24540252, -0.5508647 ])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-mean-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[ 2.14746703, -1.34989291,  0.0816425 ,  0.85190931],
       [-0...0.93746165],
       [-0.6893667 , -1.19001982,  0.80096244, -0.22386995]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-mean-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4)>
array([[-0.77773893,  0.29033649,  1.27757447,  0.34267551],
       [-1...0.2461051 ],
       [-1.19977466,  1.82420979,  0.65833967,  0.79023246]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-mean-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.41992581, -0.46383542, -0.43812697, -2.85358823],...1],
        [-0.00708875,  0.84283052, -0.80703371, -0.98233337]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[True-False-False-mean-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = False, skipna = False, as_dataset = True

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray 'data' (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.02444772, -0.81196461,  1.0789143 ,  0.98790465],...9],
        [ 1.27734192,  1.57179984,  0.23487836,  0.11166151]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([ 0.24058519,         nan, -2.60393595,  1.41784686])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([0.72715191,        nan, 0.31569321, 1.54776622])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[        nan,         nan, -0.25114308,  1.82726415],
       [ 1.454065...1.42885332],
       [-1.33903858, -2.01526168,         nan, -1.06102512]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[        nan,         nan,  2.51666639,  1.27955934],
       [        n...1.02171429],
       [ 0.31396894, -1.48113172,         nan, -0.24981701]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.23179053,         nan,         nan,  1.59904488],
      ... ],
        [ 0.39348961, -0.71866809,  0.22018592,         nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan,         nan,  1.49153809, -0.89135265],
      ...1],
        [ 0.87150507,  0.62063109, -0.7469964 ,  0.13849856]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([0.16117262,        nan, 0.39394221, 1.08697094])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([ 1.83029095, -1.73657493,         nan, -0.25886948])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-1.1799177 , -0.49191509, -0.54491911, -0.41482267],
       [ 0.718038...       nan],
       [        nan, -0.78149147, -0.40631552, -0.56971831]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.70733053, -2.26677827, -0.28902125, -0.70826169],
       [ 0.413278...1.84087406],
       [ 1.67604571, -0.44470644,         nan,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan, -0.51486297,         nan,  0.18194676],
      ...n],
        [ 0.87874391,         nan,  0.27469189,         nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 2.00209022, -0.31767621,         nan,  0.09708297],
      ...1],
        [-0.86953614, -0.62559746,  0.52878359, -0.27472092]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([-0.63342138,  0.17143923,         nan, -0.07590301])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([ 2.10019027, -1.2966955 , -0.64328729,         nan])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[        nan, -1.11155112,  0.57415749,  0.2528635 ],
       [-0.553341...0.26819626],
       [        nan, -1.80240681,  1.56965113,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.10348025,         nan, -1.43347041,  1.61938568],
       [ 2.477321...1.87734764],
       [ 1.75214144,         nan, -1.41913374,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan, -0.3389673 ,         nan, -0.89044452],
      ...3],
        [        nan, -0.23993614, -0.24646719,  1.57442559]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.25308852,  0.69423483, -0.4911393 , -0.19680181],
      ...n],
        [-0.67689126, -0.92660412,         nan,  0.79305753]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([        nan,  1.46400354, -0.8099854 , -0.75719454])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([ 0.17071663, -0.63135271,  0.63396391,         nan])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.83368531,         nan, -0.3736344 ,  1.77016049],
       [ 1.202446...2.39185049],
       [-1.66720069,  0.20971484,  0.14435437,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.75640845, -0.33301604, -0.37266391,         nan],
       [        n...0.02178976],
       [ 1.17326077,  1.03315226, -1.00767099,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.66740154, -0.26353121,  2.33695249,         nan],
      ...8],
        [ 0.11941774, -0.3494913 ,  0.37250326,  0.40596915]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.76462637,  1.5081172 , -0.90391431,  0.97671414],
      ... ],
        [ 0.48560119,         nan,         nan,  1.14078294]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([ 0.69090442,         nan, -1.00362044,  1.76467606])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([        nan,  1.92794442, -0.4169427 ,  1.08682541])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.3170077 ,         nan, -0.97812275, -0.69670351],
       [ 1.533726...2.21231696],
       [ 0.13878378,  0.93887775, -0.66342919, -0.21720096]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.3033465 ,  0.44398912,  0.09479838,  0.54942891],
       [ 0.436002...0.18942327],
       [-0.3982944 , -1.09657085, -0.02513207,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.93365743,  0.28346034,         nan,         nan],
      ...3],
        [ 0.66479502, -1.62496536,         nan,  0.81399495]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.19955725, -2.44208108, -0.02711294,         nan],
      ...7],
        [ 0.6028589 ,  1.38290696, -0.38850029,         nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([-0.73845272,         nan,  0.80871963, -1.36225784])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([-0.64824048, -0.41040555, -0.82618002,         nan])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-1.07114094,  0.03202206, -1.86883028,         nan],
       [ 1.221853...0.6295356 ],
       [-0.1961927 ,         nan, -0.54893582,  0.02763695]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[        nan, -0.8797835 ,  0.70248515,  1.19693271],
       [-0.394372...1.47367742],
       [ 1.18276247, -0.97829807,         nan, -0.22101558]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan,         nan,         nan, -1.7062465 ],
      ...9],
        [ 1.20308474,         nan, -1.22796474,         nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-sum-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan,  0.46959492,  0.2470031 , -0.36160403],
      ...n],
        [-0.10685722,  0.6046949 , -0.64691488,  1.14624775]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-mean-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([ 1.53345502,         nan, -0.45208015,  1.50526629])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-mean-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([        nan,  0.14929056,  0.14818749, -0.69978833])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-mean-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[        nan,  0.73821258,         nan,  0.9692147 ],
       [ 0.189723...0.56240176],
       [ 1.01617949,  0.63249431,  2.28365307,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-mean-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.10156937,  0.57530714, -1.33929492,  0.84608677],
       [ 1.829414...       nan],
       [ 0.1652379 , -0.22927522, -1.14626817,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-mean-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.99009546, -0.47286171, -0.92444127,  0.75188619],
      ...n],
        [-1.47535817, -0.7623724 , -1.58145616,  0.20682817]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-mean-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-1.46419561,         nan, -0.60746115,         nan],
      ...n],
        [ 0.20708241,         nan, -0.6960667 ,  0.37030144]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-mean-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([-0.18708263,  0.21353514, -0.75993085,         nan])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-mean-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([-0.63639262, -0.52086723,         nan,  0.67473385])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-mean-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.03262729,         nan, -1.30317753,  0.05270429],
       [-1.213588...0.97915296],
       [ 0.38225567,         nan, -0.09143935, -0.05811882]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-mean-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.61330771, -1.22585154,         nan, -0.68362433],
       [        n...0.97908121],
       [        nan, -1.77937346,  0.83005806,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-mean-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'mean', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.05647633,  1.66542648,  0.03767371,  1.67406256],
      ...3],
        [-1.33088371,         nan,         nan, -2.44155398]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-mean-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan, -0.56350593, -0.80214188,  0.66361188],
      ...9],
        [-0.02074784,  1.01906779,  1.4665544 , -0.68000991]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-mean-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([        nan, -0.14943438,  0.59543828,  0.2341414 ])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-mean-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([ 1.15755063,         nan, -1.35240484,  0.57673386])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-mean-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.71799483, -1.61298759, -1.52897174,         nan],
       [-1.818523...0.98014021],
       [ 0.28985444,         nan, -0.52548731,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-mean-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 6.04203980e-01,  1.39167192e+00,             nan,
         1.33482713...82892735e-01,             nan, -1.06809905e+00,
         3.67916877e-02]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-mean-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan,         nan, -0.54526689,  0.54465089],
      ...8],
        [ 2.66549832,         nan,  1.09918782,         nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-True-mean-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = True, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.53034675,         nan,         nan,  0.76891667],
      ...2],
        [-0.55140493,         nan,  1.03878949,         nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([ 0.87426048, -0.27271802,  1.1869642 ,  0.18917488])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([ 1.10601398,  0.00155952,  0.86502926, -1.31876716])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.91898424, -0.49966857,  1.61823966,  0.67789482],
       [ 0.938807...1.20938235],
       [ 0.54263762,  1.61018349,  0.38130726,  0.12441075]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 1.32575953e+00,  1.41274468e+00, -1.36721794e+00,
         2.97195179...03801404e+00, -6.53483080e-04, -6.83797579e-01,
        -6.82586670e-01]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.25010402,  1.60930403,  1.53319644, -0.89767143],
      ...9],
        [ 0.16250546,  0.03928924,  0.44817546,  0.61403415]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-2.30160266e+00,  1.17599163e-01,  5.62990623e-01,
        ...-01,  9.28085153e-01, -1.66101685e+00,
          5.39375864e-01]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([-0.9187302 , -0.37358034,  1.76416407,  0.02862906])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([-0.21681378, -0.01206389, -0.10640564, -2.01689599])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.00554933, -1.18243428,  0.5489984 ,  1.22917956],
       [-0.900855...0.33107243],
       [-0.79647834,  0.07531734, -0.49192195,  1.27837894]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 3.84516080e-01,  4.59591632e-01,  2.31210523e-01,
        -2.17668599...76465053e-03, -2.33179442e+00, -2.61653868e-01,
         1.36166353e+00]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.70847968, -1.2345819 , -1.21732385,  1.24752651],
      ...4],
        [ 0.34977035, -0.07750376,  1.29874538, -1.41311589]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.63043425, -1.2072656 ,  1.19824116, -0.62253838],
      ...6],
        [-0.92314934,  0.21795688, -1.35095888, -0.49835079]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([-0.56405342,  0.43239361,  1.37248864, -0.11615026])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([ 0.11253067, -0.33627656,  0.42399588, -1.23381489])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.43488176,  0.21607483,  0.14255741, -0.85449831],
       [ 0.843999...0.84516944],
       [ 0.15975144, -0.80004673,  0.50678558,  0.20465672]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 1.74695714, -0.85149707,  0.02109691, -0.82475571],
       [-0.250372...0.63900391],
       [ 0.01137429,  0.1651112 ,  0.50483047, -0.55099937]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.13108769,  0.0967946 , -1.66328394, -1.54866478],
      ...2],
        [-0.02435027,  0.9981404 , -1.05393498,  0.77628667]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = None
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.3389736 ,  0.94865322,  0.30977625, -1.27973427],
      ...9],
        [ 0.18096549, -0.05252684,  0.3258134 , -0.42025845]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([-0.12495769,  0.04683542, -0.63254425,  1.61890063])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([-1.24120396,  0.75138819,  1.87061208,  0.16064363])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.56429856,  0.44697655, -0.99550634,  0.58928775],
       [ 0.655529...0.96103098],
       [-1.24739631, -0.33354666,  0.18109751,  0.09654872]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.63752847,  1.07523659, -0.52171349,  0.78587051],
       [-0.919565...0.07067021],
       [ 0.48818325,  0.06364568, -0.62049326, -1.5707634 ]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.79361462,  0.04887093,  0.16899336,  0.57790452],
      ...2],
        [-1.42206183,  0.82353405, -1.90372121, -0.64209205]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.38065502,  0.11343603,  0.28085096, -1.07009931],
      ...6],
        [ 1.12762439,  1.01567067,  0.46205873,  2.62913709]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([ 1.6699319 , -0.83889967, -0.71916249, -0.32107221])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([-1.1901864 , -0.37787354, -1.13056251, -1.26392247])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 1.84889788, -0.15113046, -2.0986957 ,  1.50565018],
       [-0.602446...1.83198737],
       [ 1.40666367, -0.32686603,  0.17776697, -0.92913046]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.12390476,  1.32624228, -0.48756175,  0.17237015],
       [-1.164263...0.48875414],
       [ 1.35012755, -0.57231989, -1.78637596, -0.15745847]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.15269449,  0.45366526, -1.40959162, -0.7975118 ],
      ...3],
        [ 0.35184784, -0.00672158,  0.45949942,  1.25196922]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.56153036, -0.05523553,  1.04587898, -0.05109452],
      ...8],
        [-0.77067831,  1.0449591 , -0.92930614, -0.46446035]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([-0.62123962,  0.09266335, -0.91799378,  1.31143889])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([-2.70316309, -1.28138731,  0.08779802,  0.08851444])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.64462164,  0.29593955, -0.43951579, -1.68812684],
       [-0.830313...1.4386283 ],
       [ 1.21268427, -1.44809841,  0.3690157 , -0.7984223 ]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-2.92386306, -0.04659795,  0.37274904, -0.44890139],
       [-0.442305...0.37731568],
       [ 0.08064904, -0.67992963,  0.04521855, -0.09622407]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum', add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.18499112,  0.46433494,  2.34756001,  0.19747191],
      ...6],
        [ 0.61886144, -0.3646373 ,  0.95989903, -0.03747054]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-sum-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-1.23508084,  0.10792002, -0.62657237, -1.1540322 ],
      ...9],
        [-1.19089326, -1.12220918,  0.78074682, -0.85751775]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-mean-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([ 0.79105555, -0.09405268,  0.24761006, -0.0681721 ])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-mean-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([-0.82992588,  0.3598779 ,  1.16791391, -1.47868757])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-mean-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.11425278,  0.50931236, -0.27357383,  0.25199309],
       [-1.073023...0.94901656],
       [ 2.21646061,  0.46013453,  2.20466645,  1.1617422 ]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-mean-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 1.66247654, -0.94333971,  0.17870655,  0.7594064 ],
       [ 1.391245...1.95009681],
       [-0.77160694, -1.04961475, -1.71080143,  0.4264604 ]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-mean-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.54917246, -1.33425303, -1.01648888,  1.04454871],
      ...2],
        [ 1.40592058,  1.49604832,  0.16102721, -1.7488433 ]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-mean-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.10632529, -1.12565992, -1.36826512, -0.54936855],
      ... ],
        [-0.32064285, -0.8314411 , -1.11606762,  0.28963393]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-mean-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([ 0.1947957 ,  1.19639211, -0.46492034, -1.00803054])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-mean-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([ 1.46096223,  0.74722923, -0.60497064, -1.27255602])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-mean-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.77739077,  1.86632233, -1.3321681 ,  0.51638091],
       [ 2.189138...0.45777085],
       [ 0.89386228,  0.99348156, -0.94372439, -1.24324605]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-mean-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.21409319, -1.31075571, -0.29773784, -1.47728152],
       [ 1.149686...0.07802757],
       [ 0.01634696,  0.70369789,  2.05537561, -0.35123646]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-mean-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'mean', add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.31775397,  0.76685165,  0.60671729, -1.65810689],
      ...3],
        [ 0.74062215, -0.48277646, -0.98272274,  0.19314615]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-mean-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.70186578, -0.10966808,  0.46459599, -0.85523637],
      ...6],
        [-0.10526993, -0.39775074, -0.31968057,  1.56509867]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-mean-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([ 0.30666242, -0.73766512, -1.49218855,  0.50090786])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-mean-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([ 0.12554064, -0.89938095, -0.11302766, -0.15883069])
Dimensions without coordinates: dim_0
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-mean-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.52003149, -0.86839088,  1.75274762, -0.50131138],
       [-0.886816...0.19879339],
       [-1.55161795,  1.90863918,  0.6190528 ,  0.56031001]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-mean-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-1.54840867, -0.02265801,  1.07681737,  0.94383421],
       [-1.260759...1.27998648],
       [-0.231734  ,  0.04231018,  0.06078317,  1.15057001]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-mean-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.4190692 ,  0.69789233,  0.15569024,  0.34027964],
      ...3],
        [ 0.44247281, -0.20586011,  0.99831328,  0.12413757]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-None-False-mean-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = False, skipna = None, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.89864913,  0.29067365,  0.13687173,  0.72443696],
      ...5],
        [-0.1368625 ,  0.66095012, -0.6574281 ,  0.14331952]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([-1.6474448 ,         nan,  0.74246319,  0.48084878])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([ 0.96635536,         nan, -1.08059221, -0.86151791])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[        nan,         nan,  0.10141623,  0.23228802],
       [ 0.293529...0.23507   ],
       [        nan, -0.16953132,  0.20558392,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.94155573,  0.81209239,         nan,  0.60150576],
       [-1.984035...       nan],
       [ 0.26316226, -0.70123555, -0.37962407, -0.01007595]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 4.02507641e-01,  3.20232065e-01,  3.60781290e-01,
        ...-01, -1.68639140e+00,             nan,
                     nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.97671811,  1.31002373, -1.01192433,  1.30554876],
      ...3],
        [-0.06466761, -2.47954413,  0.85857284,         nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([ 0.17375286, -1.09879722, -0.46026561,         nan])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([-1.5030894 ,         nan,  0.11248287, -0.60463396])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[        nan,  1.88090314,  0.56215207,         nan],
       [-0.964428...0.7272336 ],
       [ 0.22022522, -0.39953613,  0.73525739, -1.04440737]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 1.68850971, -0.49547357,         nan,  1.03667554],
       [ 0.056940...0.45816195],
       [        nan, -0.809122  , -0.79783337,  0.40056721]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.25993696, -0.71812211, -0.01066393,         nan],
      ...5],
        [ 0.15078374, -0.13197808,         nan, -0.48827809]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.76587196,         nan,  1.19279275,         nan],
      ... ],
        [-0.63616127,         nan, -0.53376935, -0.1054017 ]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([ 0.7630491 , -2.97824082, -0.26972302,         nan])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([       nan, 1.83794117, 0.55502863, 1.69635496])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[        nan, -0.77536554,  1.42661561, -0.37586278],
       [-0.731949...1.46591094],
       [-0.65050834,  1.13208765,  0.95647942, -1.56795373]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 1.297455  ,         nan,  0.00438749,  0.39322271],
       [-0.973157...0.3523531 ],
       [ 0.1772294 ,  1.83903381, -0.50485856,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan,         nan,  1.03972425,  0.81585906],
      ...2],
        [-0.33061004, -0.2218234 ,         nan,         nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.63817733,  0.93422864,  0.97772426, -0.2473062 ],
      ...5],
        [        nan,  1.40232125,         nan, -0.83131231]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([1.28635435, 0.16506613, 0.5349083 ,        nan])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([1.36955409, 0.62179853,        nan, 2.0715087 ])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[        nan,  0.34011658,  2.23367774,         nan],
       [-1.546913...0.63695734],
       [-1.37267331,  1.05528994, -1.22611471, -0.80701649]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[        nan, -1.57452734, -1.03623056,  1.06021095],
       [-0.250892...2.25007642],
       [-1.48217873,         nan, -0.81453549, -1.44780378]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.45634627,  1.17528324,  0.62889333,  0.64344579],
      ...2],
        [ 1.41814813,         nan,  0.11499333,  0.73863444]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-1.05626687,  0.27727143, -0.46947135,  0.59560704],
      ...n],
        [        nan, -0.50398728,  0.83083986,  1.08456711]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([-2.16196524, -2.38110978,  0.82687705,         nan])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([-0.29669602, -0.27962102,         nan,  0.79074963])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[        nan,         nan,         nan,  2.47146941],
       [ 0.896522...       nan],
       [ 0.02944069,  0.78910665,  0.33402121,  0.66185216]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.81096758, -2.44198861,         nan,  0.00524211],
       [        n...       nan],
       [-0.76935006, -0.28146117, -1.12307741,  1.00644871]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 2.06784992e+00, -6.18795473e-01,             nan,
        ...-01,  7.94700237e-01, -8.01326853e-01,
         -2.05469993e+00]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.0313527 , -0.72727976, -0.67354501,         nan],
      ... ],
        [-0.13138273,         nan, -1.973503  ,  0.53407244]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([        nan, -0.23528022, -1.25637886,  0.01962492])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([ 0.00301532,         nan, -0.4682285 , -0.42091914])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.24862529, -0.20422072,         nan,  0.28279903],
       [ 1.526978...1.83261155],
       [ 0.04889708, -2.02800745, -1.06688066, -1.11419717]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[        nan, -0.91110702,         nan, -1.91625752],
       [ 0.348987...0.96304019],
       [ 0.98181993, -0.11929212, -0.95248026, -0.43934174]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan,         nan, -0.15158794,  0.07016418],
      ...2],
        [ 0.67208748, -1.95997084, -0.38691318,  0.5240777 ]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-sum-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan, -0.45444508,         nan,  0.0292735 ],
      ...n],
        [        nan,  0.00812262, -0.13741396,  0.21894807]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-mean-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([-2.55503635, -0.46488169,  1.34587676,         nan])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-mean-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([        nan,  1.37003569,  0.41982413, -2.13063995])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-mean-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.03498872, -1.0686985 , -0.78458597, -0.26989035],
       [ 1.571865...0.7521294 ],
       [-1.65325056,         nan, -1.69091481,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-mean-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.18832163, -0.57757788,  1.80032882,  2.79657262],
       [        n...       nan],
       [-2.05092637, -0.47931557,         nan, -0.03734061]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-mean-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.29487865, -0.64563546,         nan, -1.48441365],
      ... ],
        [        nan,         nan, -0.06144728,  0.04273529]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-mean-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.59223118, -0.00355631,         nan, -0.30052388],
      ...6],
        [ 1.14509937,         nan,  1.03887472,  1.52725236]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-mean-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([ 0.32254702, -0.56300816,         nan, -0.18790969])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-mean-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([ 0.19662387,  0.48470034, -0.36478248,         nan])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-mean-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.6501326 ,         nan,  0.83057019,         nan],
       [ 0.256571...0.03862174],
       [-0.28532961, -0.03161212, -0.18148117,  0.88046575]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-mean-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.80136688,         nan, -0.48662726, -1.76607485],
       [-1.334066...       nan],
       [-1.00084403, -1.30529   , -2.05086387,  0.47533249]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-mean-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'mean', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.21088385,  0.27566679, -0.07478386,         nan],
      ...8],
        [ 0.29382397,         nan,  0.03606693,         nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-mean-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.57651472, -0.6672249 , -0.65637989, -1.14161541],
      ...4],
        [        nan, -1.43341218,  0.06205061, -1.35213126]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-mean-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([-1.35181981,  0.99707642, -1.38706739,         nan])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-mean-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([ 0.02850536, -0.61184552,         nan,  1.10790221])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-mean-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 1.34126354, -1.22302216, -1.04212717, -0.14218316],
       [-1.438592...       nan],
       [ 0.16786586,         nan,  0.81183743,  0.34026329]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-mean-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.50585729,  0.93192528,         nan, -0.18408991],
       [ 0.131864...       nan],
       [ 1.38872539, -1.34284254, -1.74853485, -0.20474819]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-mean-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.05618494, -0.66427104,         nan,  0.04580373],
      ...8],
        [ 0.69121261,  0.46041098,  2.11458172, -0.89196179]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-True-mean-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = True, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.27145112,  0.83883434,  1.36630269, -1.17628175],
      ...7],
        [-0.00870397, -1.32915656,  0.02344257, -1.37367682]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([-0.24968905, -0.66424414,  0.74939627, -0.05406985])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([0.19005694, 0.76000595, 1.57753261, 0.11610833])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.25162062, -0.82640671,  1.92731233,  0.67138988],
       [-0.201085...0.17969759],
       [-0.11876724, -0.96796741,  0.47197704, -0.86459039]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.02250612, -2.23890467, -0.02568288,  1.62644184],
       [ 1.285566...0.1529896 ],
       [ 0.05303639,  1.67222048, -2.6382899 , -0.67712599]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.93250642,  0.39873177, -0.658721  , -0.29980685],
      ...7],
        [ 1.6790047 , -0.50496679, -1.3553009 ,  0.141658  ]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-2.07851718e-01, -1.45970308e+00,  2.64882487e-01,
        ...-01, -6.48967115e-01, -6.05842362e-02,
          1.09359575e+00]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([-0.32982293,  0.44267337,  0.34651442, -0.18784006])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([-1.91329179e-01, -6.58388640e-01,  2.19381245e-04, -7.63878930e-01])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-1.14649245, -2.24975484,  0.30495428, -0.30666471],
       [-1.581339...0.94548193],
       [ 0.47569357,  0.17185034,  1.22149408, -0.27037182]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.57340596, -0.48385081, -0.97830721,  1.40445071],
       [-0.799651...0.15200652],
       [ 0.64017772, -0.86645246, -0.33379567, -1.9725543 ]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.74962954, -0.61567347, -0.11054707,  0.18695395],
      ...7],
        [ 1.62759343, -0.79718622,  0.82010453, -0.08646998]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.15605308, -0.34570398,  0.23118163,  0.15186598],
      ...4],
        [ 0.64602657,  0.54858833, -0.26776275,  0.70174913]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([-0.12805435, -1.69133414,  0.22910519, -1.48243692])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([ 0.36683973, -0.39012737, -0.89864177, -0.37648232])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.15321616,  0.43145868, -0.68633963, -0.61469889],
       [ 0.998504...1.45377096],
       [-0.12311716, -0.88021375, -0.6348282 , -0.07395348]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.02175121,  1.44636019,  1.50278648,  1.88260407],
       [-0.246245...0.77965118],
       [ 0.82237117,  0.88799824, -0.94593657,  2.5158248 ]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-7.74186085e-01,  5.44552054e-01,  1.15158873e+00,
        ...+00,  6.69457570e-02,  5.16547354e-01,
         -1.04732385e+00]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = True
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.05108618e+00, -6.08579477e-01, -1.28058965e+00,
        ...-01, -1.25978390e+00,  1.08795279e-01,
          1.75578397e+00]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([ 1.11037443,  0.00626213, -0.63566876, -1.78384801])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([-0.78522231,  1.11701595,  0.01849656, -0.50731819])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.21175543,  0.26360497, -1.78662211, -0.29021772],
       [ 0.613127...0.27618059],
       [ 0.29099441,  1.21083285, -0.70829292, -0.02793906]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.60445157,  0.7794864 ,  0.22815941, -0.92504027],
       [ 0.716183...0.62669642],
       [ 0.82722384,  0.8526395 ,  1.89043364,  0.96605488]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.78401098,  0.432845  ,  0.55173624, -0.82965683],
      ...1],
        [ 0.98410997,  0.8501536 , -0.35994642,  0.19570199]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.29901885,  0.51376307,  0.20205849, -0.85306995],
      ...2],
        [-0.77825426, -1.64862483, -0.32537051,  0.42125384]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([-0.82919576, -1.71765819,  0.98508918,  0.59885791])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([-0.72291188, -0.46818644,  0.88666164, -0.50744097])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-1.72340749,  0.49665297,  0.32013726, -0.96445633],
       [ 0.297995...1.3627056 ],
       [ 0.04480615,  2.80746943, -0.08610678, -1.60499004]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.21518815,  0.1960301 ,  0.40618224,  1.14019322],
       [-0.340350...0.94352554],
       [-0.42490584, -1.46284744, -0.20983537, -1.42182744]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.98343319,  0.03371985, -1.16521619, -0.36056103],
      ...8],
        [-0.13083509, -0.78350931, -0.87102134,  2.37718178]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.56255319, -0.81277325,  0.1170427 ,  0.67030648],
      ...1],
        [-0.11475492, -1.88260234,  0.98243205, -0.69815669]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([-1.26264543, -1.29095783, -1.48442803,  0.68953202])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([0.29411503, 0.67950817, 0.99754343, 0.21879329])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.4531764 ,  0.80710099,  0.93061008, -0.91703562],
       [ 0.281064...0.02192478],
       [ 0.37880711, -1.71198082, -1.85954083, -2.61997727]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.47413382,  0.70219255,  0.21717298,  0.56552945],
       [-0.362887...0.65323762],
       [ 1.00219168, -2.58277161, -1.17288783, -0.6873385 ]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum', add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.87828446, -1.40615992,  0.34363238,  0.03731097],
      ... ],
        [-1.40562323, -1.3942971 ,  0.73769869,  0.23818978]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-sum-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.09815941,  1.05440164, -0.70076743, -1.45360276],
      ...7],
        [-1.62850297,  0.64791186,  1.05762609, -0.74144549]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-mean-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([ 1.60227996, -1.28476025, -2.140274  , -0.45038198])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-mean-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([-0.68618133,  0.5731084 , -0.52436597, -0.82441577])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-mean-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.51538553,  0.09962752,  0.32601764,  0.19076237],
       [ 2.231717...2.08124974],
       [-0.07790749,  0.57484005,  0.34631974,  0.19378446]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-mean-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.82911283, -2.97896007,  1.0473092 , -2.08655707],
       [ 1.864030...2.56413974],
       [ 0.348161  , -0.33580478,  0.76807756, -0.18750567]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-mean-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.82233425, -0.53788265, -1.94485178, -0.93960113],
      ...1],
        [ 1.52289782,  0.50215016,  0.07870817, -0.89688315]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-mean-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.87367365, -1.24082953, -1.33278348,  1.40056941],
      ...3],
        [-0.99114461, -1.45205187, -3.12339397, -0.44414325]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-mean-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([ 1.31718462,  0.39254294,  0.66564667, -0.43032799])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-mean-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([0.90388256, 0.31178394, 0.28942013, 0.03636164])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-mean-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.75630531,  0.14922105,  0.42222957,  0.05203679],
       [-0.237126...0.15516373],
       [-0.3307768 , -0.7558918 ,  0.33705447,  0.56230772]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-mean-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.14775924,  0.0315925 , -1.59552321,  0.29901091],
       [ 0.200317...0.65450675],
       [-0.77524612,  1.73537273, -0.85611656,  0.50060894]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-mean-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'mean', add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.36790724,  1.25906446, -0.43628828,  0.36666323],
      ...9],
        [ 0.7858855 ,  0.82221173, -0.83283495,  1.32870069]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-mean-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.87571788, -1.95068319,  0.21468033, -2.58044278],
      ...3],
        [ 1.59723735, -0.49908614,  0.49451859, -1.48597328]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-mean-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([-0.71372519,  1.84939386,  0.07680383, -1.82678274])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-mean-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([-1.27707533,  0.5889989 ,  0.43396103, -0.93210422])
Dimensions without coordinates: dim_0
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-mean-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.642724  ,  2.06199304, -0.77933948,  0.21393842],
       [ 0.585147...2.34043702],
       [ 1.10955766,  1.61445369, -0.6104657 , -1.5324692 ]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-mean-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.40342027,  0.58629029, -0.06695113, -0.2326684 ],
       [ 0.048675...0.25258561],
       [ 1.44563427,  1.90591618,  0.36955973,  1.05516293]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-mean-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.44380768,  0.2157401 ,  0.89689998,  0.27466348],
      ...3],
        [-0.97629534,  0.06607325, -0.20393316, -0.5209432 ]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-True-False-mean-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = False, skipna = True, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.62357114,  0.90176055, -0.56745158,  1.32755136],
      ...8],
        [ 0.45440148,  1.08352465, -0.52675308, -0.08277193]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = True

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([ 0.60208599,  2.10559708, -1.0835795 ,         nan])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([        nan, -0.01164436,  0.56197364,  0.44695711])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[        nan, -0.80049578, -1.54490768,  0.10732477],
       [        n...       nan],
       [-2.07056474, -0.54076631,  1.62865435,  0.14843184]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[        nan, -0.24908385,  1.33195229,  0.09791299],
       [-0.089035...1.27545068],
       [-0.87578765, -0.27640082, -0.69342071, -0.12465219]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.36276449, -0.43833343, -0.31057767,  1.0540344 ],
      ...n],
        [ 0.85197287,  1.64474671,  0.61185946,  0.66897271]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-2.03448424e-01,  9.13798735e-01,  1.20861967e-01,
        ...-03,  8.85760219e-01, -9.29926982e-01,
                     nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([-0.47373192,         nan, -0.06678479,  1.85316856])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([-1.93333389, -0.25260638, -0.08880319,         nan])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[        nan,  0.09921007, -0.07147192, -0.56849188],
       [ 0.357149...1.58061061],
       [        nan,         nan, -1.22224969,  0.24945137]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.98617681,         nan, -1.2346278 , -1.47599424],
       [ 0.520422...       nan],
       [        nan,  0.04139063,  1.39236415,  0.09672523]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.54802238, -0.78949886,  0.40045237,  0.88498211],
      ...n],
        [ 1.31957669,  0.36096936, -1.31298082, -0.28920595]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.17797575, -0.02950161,  0.83563431, -0.28190836],
      ...7],
        [-1.40962852,         nan, -0.89642904,  0.63618372]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([-0.25744625,  0.9789214 ,         nan, -0.68448182])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([        nan,  0.52801962, -0.15209487, -0.06022599])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-1.57004201,  0.75072382, -1.04498055,  0.33959429],
       [        n...       nan],
       [        nan,  0.71852787,  0.91290714,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.9917421 ,         nan, -0.45288146, -1.61122152],
       [        n...1.59156915],
       [-0.18003741, -0.85993945, -0.22750226,  0.63424366]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.45978009, -0.9825139 , -1.68861279,  0.01458891],
      ...2],
        [-1.11957567,  1.00383382,         nan, -1.67823075]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = True, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.06141632,  0.12114091, -1.18770071,         nan],
      ...9],
        [-1.89550746, -0.4605546 , -0.12666101, -0.5890715 ]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([ 0.90661931,         nan,  0.12455625, -0.6547647 ])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([        nan, -0.27600507, -0.00936181, -1.6105271 ])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.61241509,         nan, -0.54226257, -1.43775463],
       [-0.407259...1.26973956],
       [-0.27346841,  0.02842316, -0.95916204,  0.78880252]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[        nan,         nan,  0.89439376,  0.62176297],
       [-0.267179...0.61606071],
       [ 1.36475851, -0.69410872,  0.383262  , -0.83356404]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.12578308,         nan,         nan,         nan],
      ... ],
        [ 0.86083239, -1.2768026 ,  0.809392  , -1.64604426]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan,  0.99305904, -0.0986817 ,  0.23562103],
      ...1],
        [ 0.76056234, -0.01870335, -0.37653409,  0.95548476]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([        nan, -0.35194894, -1.00183005, -0.84626103])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([        nan, -0.29197661, -0.49570723,  0.52782652])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[        nan, -0.13549212, -0.99091698,  0.37547726],
       [-0.018632...1.43393771],
       [        nan,  0.50371752, -0.78278866,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.19866689,         nan,         nan,  0.16881721],
       [-2.992467...       nan],
       [ 0.75842207,  0.63114524,  1.18243571,  0.77823987]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.83541574,  0.37019632, -0.08372209, -1.18116386],
      ...9],
        [-0.42803233, -0.10069004,         nan, -0.06758698]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.31535599,  1.75842264,         nan, -0.47850289],
      ...n],
        [ 1.47701627,  0.08768881,         nan,         nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([ 0.53712533, -0.69071214,  0.27074232,         nan])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([-0.53164078,  1.53174869,         nan, -0.48687987])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[        nan, -1.23740298,         nan, -0.97039116],
       [        n...0.24578462],
       [-1.42083308,  0.25939473, -1.35212722,  0.72464657]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-1.04049881,         nan,         nan,  0.21303957],
       [-1.095600...1.08559232],
       [ 0.907989  , -0.95751191,  1.90467935,  0.89261445]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum', add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.04352706,         nan,         nan,         nan],
      ...5],
        [        nan,         nan,  0.9120982 , -0.40611311]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-sum-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.44932285,         nan,         nan,  0.1830237 ],
      ...1],
        [ 0.50018616,         nan, -1.10484977,  1.8040294 ]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-mean-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([ 0.42266573,         nan, -0.10804318, -0.27816314])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-mean-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([0.04346942, 0.32529324, 0.94411479,        nan])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-mean-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 1.66516931,  1.12679069,         nan, -1.7870816 ],
       [ 0.244720...0.73860593],
       [        nan, -0.71378043, -0.25200683,  0.72393887]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-mean-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[        nan,  1.9000502 ,  0.66749459, -0.05949222],
       [-0.284170...1.26038944],
       [        nan,         nan,  0.51082548,  0.703606  ]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-mean-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 1.44463188e+00,  1.02285856e+00, -1.02625231e-03,
        ...+00,  9.97791690e-01, -4.49452204e-01,
          4.42969177e-01]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-mean-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-1.00808968e+00, -1.89056736e+00,  1.29753448e+00,
        ...-01, -3.16573237e+00,             nan,
          2.72358000e-01]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-mean-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([-1.09651617, -1.42423031,         nan,  0.38836955])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-mean-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([0.63991069, 1.23608311,        nan, 1.07068048])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-mean-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.0842671 ,  1.31601007,         nan,         nan],
       [-0.035197...       nan],
       [-0.77077247, -1.52267704,         nan,  0.49467404]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-mean-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[        nan,  1.19320328,  1.14830861,  0.38388607],
       [-1.015417...1.73093264],
       [-1.11397041,         nan, -0.8211215 ,         nan]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-mean-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'mean', add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[        nan, -0.76888973,  0.07009104, -0.58221114],
      ...6],
        [-1.38656715,  0.40307692, -0.99177782, -1.47340915]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-mean-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-9.92303653e-01, -6.38706939e-01,             nan,
        ...-01,             nan,             nan,
                     nan]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-mean-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([ 0.16280793, -0.49470807, -0.74352488,         nan])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-mean-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([0.35773091, 0.5107008 , 0.57090855,        nan])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-mean-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.56995771, -1.97768001, -0.10109502, -0.76901753],
       [ 0.545960...0.37001688],
       [        nan, -1.27444701,         nan,  0.53596563]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-mean-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 2.3470282 ,  0.23966427, -1.42463224, -1.45289133],
       [        n...       nan],
       [ 1.19866099,  0.20761707,  1.66101176,  1.40643971]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-mean-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.02898988,  0.80144141, -1.40541814, -0.22790204],
      ...1],
        [        nan, -1.35718676, -0.5519117 , -0.76382875]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-True-mean-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = True, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.09023534, -1.23347251, -2.45655357,  0.12408505],
      ...7],
        [        nan,         nan,         nan, -1.16266848]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([-0.18737189,  2.10863979,  0.19403649,  0.31989052])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([ 0.62287695,  0.33859926, -0.20523711,  0.18601861])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 1.11163128, -1.40211447,  2.11080803, -0.88697415],
       [ 1.021034...0.7937301 ],
       [ 0.16903779, -0.97001213,  0.63984464,  1.46561587]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.59261986, -0.37661644, -1.8411823 ,  1.33236193],
       [-0.626232...0.88522711],
       [ 0.56104509,  1.85247446, -1.10446469,  0.97741457]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 7.99034615e-02, -2.23627425e+00, -6.96442097e-01,
        ...+00,  1.95843259e+00, -7.28090577e-01,
         -3.63049142e-02]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.28435709, -0.20826731, -0.17764449,  0.13201137],
      ...8],
        [ 0.58675899,  0.5497357 , -0.52577848,  0.19983113]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([-0.59909427,  0.6366618 ,  0.32459955,  0.16185321])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([ 1.03961707,  0.95049824, -1.03991802, -0.2972142 ])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 1.14768065,  0.84075955,  0.83363389, -0.38085464],
       [ 1.769667...0.67824089],
       [ 1.53975346, -0.02679829,  1.6303513 , -0.28815787]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.59147949, -1.24599408,  1.46262687,  1.77401059],
       [ 0.470484...1.03268495],
       [-0.3141245 ,  0.2753336 ,  0.32704851, -0.26820373]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.1446845 , -0.0042013 ,  1.81097068, -0.65900234],
      ...5],
        [-1.14934809, -1.53774165, -2.6938329 ,  0.96591537]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.15268291, -1.56400023, -0.26582925, -0.65551995],
      ... ],
        [ 1.88111993, -0.44359767, -1.96128606,  0.86087036]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([-0.19323454,  1.8945925 , -1.27612759,  0.20961579])
Dimensions without coordinates: dim_0
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([ 0.48855318,  0.63731323, -0.94370696,  0.27335245])
Dimensions without coordinates: dim_0
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 5.34329809e-01, -9.59233078e-01, -1.08606284e+00,
         2.60868890...50700416e-01, -1.19185928e+00,  4.68841180e-01,
         7.41942968e-01]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.37039395, -1.17879155, -0.48763567,  0.97843878],
       [-0.905213...0.5190832 ],
       [ 0.75313738, -0.29185858, -1.02473003,  0.24125639]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.30357148,  0.80936042, -0.47522754,  0.34045881],
      ...5],
        [-0.3314422 , -1.13363807,  0.41901023, -0.07310985]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0'

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum_of_weights', add_nans = False, skipna = False
as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
>           result = getattr(data.weighted(weights), operation)(dim)

xarray/tests/test_weighted.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.43349747, -0.42382884, -0.45287575,  0.05299053],
      ...3],
        [ 0.58713965, -0.64497605,  0.55940553,  0.10765755]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([-0.91744592,  0.3674367 , -1.28961071, -0.53585524])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([ 0.73680856, -0.51188903, -0.47266466, -0.4982241 ])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.34181673,  0.23797762,  0.56657831,  0.98089998],
       [ 0.415166...0.25255102],
       [-0.91255392, -1.25754157, -0.6578781 , -0.21738066]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-1.01869673,  2.54926297, -0.01519347,  0.56365755],
       [ 0.064093...1.63551619],
       [ 1.85835476, -0.75802635, -0.1898438 ,  0.39809751]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.76413793, -0.52263156,  0.92602939, -0.11146129],
      ...2],
        [-0.91601989,  0.48700267, -2.01915934,  0.72391353]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'sum'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.57800913,  1.1480988 , -0.8713214 , -0.55672275],
      ...7],
        [ 0.41920377, -0.42457471, -2.42299185,  0.16221633]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([-0.48547133, -1.47593176, -0.5287899 , -0.63824215])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([ 1.15064505, -2.24638384,  0.08014506, -0.28798778])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-1.69699128,  1.31065952,  1.23878045,  0.09624085],
       [-0.078943...0.4002941 ],
       [-0.72210553, -1.09118562,  1.52838111, -1.94655749]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 1.7500474 ,  0.74404776,  0.50883262, -0.27278571],
       [ 0.346426...1.12965357],
       [-0.7460891 , -0.69771802,  0.30513686,  0.614846  ]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-1.64973596, -0.87674519, -0.08775421, -0.93666867],
      ...3],
        [-0.97180216, -0.70407493, -1.38125041, -0.58131979]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.0287596 , -0.76800401,  0.32679741, -0.12678198],
      ...1],
        [ 0.53190253, -0.57268276,  0.5278956 ,  1.59056474]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([ 0.102353  , -0.15849267,  0.00801609,  0.28817528])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([ 0.4060196 , -0.66531908,  0.53032903,  0.29909864])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.94700464,  2.44450338, -0.61448281, -0.67139136],
       [ 0.339956...0.30016154],
       [ 0.91591581,  0.27186343,  2.43375672,  0.6074273 ]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 1.12938531,  1.21851456,  0.97800571,  0.27678496],
       [ 0.634757...0.43218947],
       [-0.51141623,  0.49952243,  0.71187996, -0.27411794]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'sum', add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.18659153,  1.07395647, -0.39384062,  1.59485781],
      ...7],
        [-1.39620081, -0.54568567, -0.41573827, -0.20654794]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-sum-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4), operation = 'sum'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.12666688,  0.53039878,  0.47872594, -1.02393493],
      ...4],
        [ 0.48609487, -0.03911946,  0.07604677, -1.14101371]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-mean-shape_weights0-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([-0.53556186, -0.06812821, -1.09244732, -0.07236107])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-mean-shape_weights0-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4)>
array([ 0.75340916, -0.37576305,  0.45235327,  0.26628993])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-mean-shape_weights0-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 1.08845389, -1.28501445, -1.42255349, -0.43331542],
       [-0.663022...0.17485018],
       [-0.61950901,  2.46463204,  1.47124963,  1.00496679]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-mean-shape_weights0-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.99835276, -0.44021901, -2.00993648,  0.79181929],
       [-1.750995...0.11390966],
       [-0.60610583, -1.4234239 , -0.73264488,  1.03198268]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-mean-shape_weights0-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-1.43756189, -0.68010728, -0.03282449, -0.25671241],
      ...6],
        [-2.78881031, -0.58547514,  0.6154866 , -0.85119336]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-mean-shape_weights0-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4,), operation = 'mean'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.1598213 , -1.79666173,  0.41188292,  0.23011463],
      ...7],
        [-0.09538199,  0.23996469, -0.05482209,  0.72848094]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-mean-shape_weights1-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([-0.11052859,  0.40244376,  1.56525266,  1.06612596])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-mean-shape_weights1-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4)>
array([-1.21635253,  1.52775801, -1.45716359,  0.35975834])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-mean-shape_weights1-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.419738  ,  0.70136317,  2.71756824, -0.46079847],
       [-0.170836...1.23502661],
       [-0.23446466,  0.60367938, -0.46759574, -0.48695575]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-mean-shape_weights1-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-0.75307421, -0.37914987, -0.58191887,  1.31096796],
       [-0.921115...0.80423657],
       [ 0.08011852, -0.86313305,  0.35462255,  1.97350842]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-mean-shape_weights1-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4)
operation = 'mean', add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[-0.46004455, -0.31908741, -1.44295838, -0.05240031],
      ...6],
        [ 0.86251945,  1.26525451,  0.3301286 , -1.58175512]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-mean-shape_weights1-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4), operation = 'mean'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 7.36685999e-01, -1.08876143e+00,  1.51823260e-02,
        ...+00, -8.03894441e-01, -1.28933132e+00,
         -1.94028049e+00]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-mean-shape_weights2-shape_data0-dim_0] _

dim = 'dim_0', shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([-0.8814995 ,  0.63987728, -0.8385985 ,  0.7256014 ])
Dimensions without coordinates: dim_0
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-mean-shape_weights2-shape_data0-None] _

dim = None, shape_data = (4,), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4)>
array([-1.3374048 ,  0.3166789 , -0.37726288, -0.07605304])
Dimensions without coordinates: dim_0
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-mean-shape_weights2-shape_data1-dim_0] _

dim = 'dim_0', shape_data = (4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[-1.31856698, -1.09848189, -1.10643554, -0.1797994 ],
       [-0.513980...1.89027802],
       [-1.94290684, -0.94761791,  0.78368716,  0.25530865]])
Dimensions without coordinates: dim_0, dim_1
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-mean-shape_weights2-shape_data1-None] _

dim = None, shape_data = (4, 4), shape_weights = (4, 4, 4), operation = 'mean'
add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4)>
array([[ 0.43313233, -0.99171925,  0.62673228,  0.9231616 ],
       [-1.208180...1.55243014],
       [ 1.47448894,  0.33940854, -0.12030957, -1.15199585]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-mean-shape_weights2-shape_data2-dim_0] _

dim = 'dim_0', shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.01528172,  0.22445021,  0.40758971, -1.66851278],
      ...7],
        [ 1.29754958, -0.81073671,  0.71260983,  1.0761448 ]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = 'dim_0', skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_ test_weighted_operations_different_shapes[False-False-False-mean-shape_weights2-shape_data2-None] _

dim = None, shape_data = (4, 4, 4), shape_weights = (4, 4, 4)
operation = 'mean', add_nans = False, skipna = False, as_dataset = False

    @pytest.mark.parametrize("dim", ("dim_0", None))
    @pytest.mark.parametrize("shape_data", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("shape_weights", ((4,), (4, 4), (4, 4, 4)))
    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("add_nans", (True, False))
    @pytest.mark.parametrize("skipna", (None, True, False))
    @pytest.mark.parametrize("as_dataset", (True, False))
    def test_weighted_operations_different_shapes(
        dim, shape_data, shape_weights, operation, add_nans, skipna, as_dataset
    ):
    
        weights = DataArray(np.random.randn(*shape_weights))
    
        data = np.random.randn(*shape_data)
    
        # add approximately 25 % NaNs
        if add_nans:
            c = int(data.size * 0.25)
            data.ravel()[np.random.choice(data.size, c, replace=False)] = np.NaN
    
        data = DataArray(data)
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        if operation == "sum_of_weights":
            result = getattr(data.weighted(weights), operation)(dim)
        else:
>           result = getattr(data.weighted(weights), operation)(dim, skipna=skipna)

xarray/tests/test_weighted.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1, dim_2
da = <xarray.DataArray (dim_0: 4, dim_1: 4, dim_2: 4)>
array([[[ 0.15248834, -0.68867441,  1.9028262 , -0.59664577],
      ...3],
        [ 2.98660404, -0.20356992, -0.21464369, -0.10083922]]])
Dimensions without coordinates: dim_0, dim_1, dim_2
dim = None, skipna = False

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________ test_weighted_operations_keep_attr[True-True-sum_of_weights] _________

operation = 'sum_of_weights', as_dataset = True, keep_attrs = True

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    @pytest.mark.parametrize("keep_attrs", (True, False, None))
    def test_weighted_operations_keep_attr(operation, as_dataset, keep_attrs):
    
        weights = DataArray(np.random.randn(2, 2), attrs=dict(attr="weights"))
        data = DataArray(np.random.randn(2, 2))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        data.attrs = dict(attr="weights")
    
>       result = getattr(data.weighted(weights), operation)(keep_attrs=True)

xarray/tests/test_weighted.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 2, dim_1: 2)>
array([[-1.59064573, -0.25137554],
       [-0.49968245, -1.10078151]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______________ test_weighted_operations_keep_attr[True-True-sum] _______________

operation = 'sum', as_dataset = True, keep_attrs = True

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    @pytest.mark.parametrize("keep_attrs", (True, False, None))
    def test_weighted_operations_keep_attr(operation, as_dataset, keep_attrs):
    
        weights = DataArray(np.random.randn(2, 2), attrs=dict(attr="weights"))
        data = DataArray(np.random.randn(2, 2))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        data.attrs = dict(attr="weights")
    
>       result = getattr(data.weighted(weights), operation)(keep_attrs=True)

xarray/tests/test_weighted.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 2, dim_1: 2)>
array([[0.20646303, 0.30950599],
       [0.63552667, 0.18634627]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_keep_attr[True-True-mean] ______________

operation = 'mean', as_dataset = True, keep_attrs = True

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    @pytest.mark.parametrize("keep_attrs", (True, False, None))
    def test_weighted_operations_keep_attr(operation, as_dataset, keep_attrs):
    
        weights = DataArray(np.random.randn(2, 2), attrs=dict(attr="weights"))
        data = DataArray(np.random.randn(2, 2))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        data.attrs = dict(attr="weights")
    
>       result = getattr(data.weighted(weights), operation)(keep_attrs=True)

xarray/tests/test_weighted.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 2, dim_1: 2)>
array([[-0.5442747 ,  1.25036084],
       [ 0.234512  , -0.50602698]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________ test_weighted_operations_keep_attr[True-False-sum_of_weights] _________

operation = 'sum_of_weights', as_dataset = False, keep_attrs = True

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    @pytest.mark.parametrize("keep_attrs", (True, False, None))
    def test_weighted_operations_keep_attr(operation, as_dataset, keep_attrs):
    
        weights = DataArray(np.random.randn(2, 2), attrs=dict(attr="weights"))
        data = DataArray(np.random.randn(2, 2))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        data.attrs = dict(attr="weights")
    
>       result = getattr(data.weighted(weights), operation)(keep_attrs=True)

xarray/tests/test_weighted.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 2, dim_1: 2)>
array([[ 0.73083118,  1.43024934],
       [-0.98529332,  0.80394553]])
Dimensions without coordinates: dim_0, dim_1
Attributes:
    attr:     weights
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______________ test_weighted_operations_keep_attr[True-False-sum] ______________

operation = 'sum', as_dataset = False, keep_attrs = True

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    @pytest.mark.parametrize("keep_attrs", (True, False, None))
    def test_weighted_operations_keep_attr(operation, as_dataset, keep_attrs):
    
        weights = DataArray(np.random.randn(2, 2), attrs=dict(attr="weights"))
        data = DataArray(np.random.randn(2, 2))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        data.attrs = dict(attr="weights")
    
>       result = getattr(data.weighted(weights), operation)(keep_attrs=True)

xarray/tests/test_weighted.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 2, dim_1: 2)>
array([[-0.61174823,  0.39241727],
       [ 0.53515352,  0.43300126]])
Dimensions without coordinates: dim_0, dim_1
Attributes:
    attr:     weights
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_keep_attr[True-False-mean] ______________

operation = 'mean', as_dataset = False, keep_attrs = True

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    @pytest.mark.parametrize("keep_attrs", (True, False, None))
    def test_weighted_operations_keep_attr(operation, as_dataset, keep_attrs):
    
        weights = DataArray(np.random.randn(2, 2), attrs=dict(attr="weights"))
        data = DataArray(np.random.randn(2, 2))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        data.attrs = dict(attr="weights")
    
>       result = getattr(data.weighted(weights), operation)(keep_attrs=True)

xarray/tests/test_weighted.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 2, dim_1: 2)>
array([[1.38616866, 0.50182527],
       [0.36800682, 1.5145922 ]])
Dimensions without coordinates: dim_0, dim_1
Attributes:
    attr:     weights
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________ test_weighted_operations_keep_attr[False-True-sum_of_weights] _________

operation = 'sum_of_weights', as_dataset = True, keep_attrs = False

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    @pytest.mark.parametrize("keep_attrs", (True, False, None))
    def test_weighted_operations_keep_attr(operation, as_dataset, keep_attrs):
    
        weights = DataArray(np.random.randn(2, 2), attrs=dict(attr="weights"))
        data = DataArray(np.random.randn(2, 2))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        data.attrs = dict(attr="weights")
    
>       result = getattr(data.weighted(weights), operation)(keep_attrs=True)

xarray/tests/test_weighted.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 2, dim_1: 2)>
array([[ 2.26839293, -0.01624286],
       [-1.60009794,  0.58552628]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______________ test_weighted_operations_keep_attr[False-True-sum] ______________

operation = 'sum', as_dataset = True, keep_attrs = False

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    @pytest.mark.parametrize("keep_attrs", (True, False, None))
    def test_weighted_operations_keep_attr(operation, as_dataset, keep_attrs):
    
        weights = DataArray(np.random.randn(2, 2), attrs=dict(attr="weights"))
        data = DataArray(np.random.randn(2, 2))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        data.attrs = dict(attr="weights")
    
>       result = getattr(data.weighted(weights), operation)(keep_attrs=True)

xarray/tests/test_weighted.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 2, dim_1: 2)>
array([[ 0.51156635,  0.31060074],
       [-0.68347864, -0.45116608]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_keep_attr[False-True-mean] ______________

operation = 'mean', as_dataset = True, keep_attrs = False

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    @pytest.mark.parametrize("keep_attrs", (True, False, None))
    def test_weighted_operations_keep_attr(operation, as_dataset, keep_attrs):
    
        weights = DataArray(np.random.randn(2, 2), attrs=dict(attr="weights"))
        data = DataArray(np.random.randn(2, 2))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        data.attrs = dict(attr="weights")
    
>       result = getattr(data.weighted(weights), operation)(keep_attrs=True)

xarray/tests/test_weighted.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 2, dim_1: 2)>
array([[ 0.32760529,  0.85472102],
       [-0.46355113, -1.09461535]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________ test_weighted_operations_keep_attr[False-False-sum_of_weights] ________

operation = 'sum_of_weights', as_dataset = False, keep_attrs = False

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    @pytest.mark.parametrize("keep_attrs", (True, False, None))
    def test_weighted_operations_keep_attr(operation, as_dataset, keep_attrs):
    
        weights = DataArray(np.random.randn(2, 2), attrs=dict(attr="weights"))
        data = DataArray(np.random.randn(2, 2))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        data.attrs = dict(attr="weights")
    
>       result = getattr(data.weighted(weights), operation)(keep_attrs=True)

xarray/tests/test_weighted.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 2, dim_1: 2)>
array([[ 1.39399315, -1.35298871],
       [ 0.03379637,  0.8552764 ]])
Dimensions without coordinates: dim_0, dim_1
Attributes:
    attr:     weights
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
_____________ test_weighted_operations_keep_attr[False-False-sum] ______________

operation = 'sum', as_dataset = False, keep_attrs = False

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    @pytest.mark.parametrize("keep_attrs", (True, False, None))
    def test_weighted_operations_keep_attr(operation, as_dataset, keep_attrs):
    
        weights = DataArray(np.random.randn(2, 2), attrs=dict(attr="weights"))
        data = DataArray(np.random.randn(2, 2))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        data.attrs = dict(attr="weights")
    
>       result = getattr(data.weighted(weights), operation)(keep_attrs=True)

xarray/tests/test_weighted.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 2, dim_1: 2)>
array([[-1.16538387, -1.07178114],
       [-0.52342006,  1.17924057]])
Dimensions without coordinates: dim_0, dim_1
Attributes:
    attr:     weights
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_keep_attr[False-False-mean] _____________

operation = 'mean', as_dataset = False, keep_attrs = False

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    @pytest.mark.parametrize("keep_attrs", (True, False, None))
    def test_weighted_operations_keep_attr(operation, as_dataset, keep_attrs):
    
        weights = DataArray(np.random.randn(2, 2), attrs=dict(attr="weights"))
        data = DataArray(np.random.randn(2, 2))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        data.attrs = dict(attr="weights")
    
>       result = getattr(data.weighted(weights), operation)(keep_attrs=True)

xarray/tests/test_weighted.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 2, dim_1: 2)>
array([[ 0.12246251, -0.4467427 ],
       [ 0.36114777,  1.79053885]])
Dimensions without coordinates: dim_0, dim_1
Attributes:
    attr:     weights
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_________ test_weighted_operations_keep_attr[None-True-sum_of_weights] _________

operation = 'sum_of_weights', as_dataset = True, keep_attrs = None

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    @pytest.mark.parametrize("keep_attrs", (True, False, None))
    def test_weighted_operations_keep_attr(operation, as_dataset, keep_attrs):
    
        weights = DataArray(np.random.randn(2, 2), attrs=dict(attr="weights"))
        data = DataArray(np.random.randn(2, 2))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        data.attrs = dict(attr="weights")
    
>       result = getattr(data.weighted(weights), operation)(keep_attrs=True)

xarray/tests/test_weighted.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 2, dim_1: 2)>
array([[ 0.97144968, -1.35194718],
       [ 0.72464393, -1.3515502 ]])
Dimensions without coordinates: dim_0, dim_1
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______________ test_weighted_operations_keep_attr[None-True-sum] _______________

operation = 'sum', as_dataset = True, keep_attrs = None

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    @pytest.mark.parametrize("keep_attrs", (True, False, None))
    def test_weighted_operations_keep_attr(operation, as_dataset, keep_attrs):
    
        weights = DataArray(np.random.randn(2, 2), attrs=dict(attr="weights"))
        data = DataArray(np.random.randn(2, 2))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        data.attrs = dict(attr="weights")
    
>       result = getattr(data.weighted(weights), operation)(keep_attrs=True)

xarray/tests/test_weighted.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 2, dim_1: 2)>
array([[-0.45167096,  1.0390453 ],
       [ 0.24500849,  1.2902866 ]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
______________ test_weighted_operations_keep_attr[None-True-mean] ______________

operation = 'mean', as_dataset = True, keep_attrs = None

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    @pytest.mark.parametrize("keep_attrs", (True, False, None))
    def test_weighted_operations_keep_attr(operation, as_dataset, keep_attrs):
    
        weights = DataArray(np.random.randn(2, 2), attrs=dict(attr="weights"))
        data = DataArray(np.random.randn(2, 2))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        data.attrs = dict(attr="weights")
    
>       result = getattr(data.weighted(weights), operation)(keep_attrs=True)

xarray/tests/test_weighted.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:238: in _implementation
    return self.obj.map(func, dim=dim, **kwargs)
xarray/core/dataset.py:4355: in map
    variables = {
xarray/core/dataset.py:4356: in <dictcomp>
    k: maybe_wrap_array(v, func(v, *args, **kwargs))
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DatasetWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray 'data' (dim_0: 2, dim_1: 2)>
array([[-0.51413711,  1.13882699],
       [-0.78358215,  0.44630851]])
Dimensions without coordinates: dim_0, dim_1
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
________ test_weighted_operations_keep_attr[None-False-sum_of_weights] _________

operation = 'sum_of_weights', as_dataset = False, keep_attrs = None

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    @pytest.mark.parametrize("keep_attrs", (True, False, None))
    def test_weighted_operations_keep_attr(operation, as_dataset, keep_attrs):
    
        weights = DataArray(np.random.randn(2, 2), attrs=dict(attr="weights"))
        data = DataArray(np.random.randn(2, 2))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        data.attrs = dict(attr="weights")
    
>       result = getattr(data.weighted(weights), operation)(keep_attrs=True)

xarray/tests/test_weighted.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:186: in sum_of_weights
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 2, dim_1: 2)>
array([[ 0.3560719 , -1.85611045],
       [ 0.43348906, -0.59400065]])
Dimensions without coordinates: dim_0, dim_1
Attributes:
    attr:     weights
dim = None

    def _sum_of_weights(
        self, da: "DataArray", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None
    ) -> "DataArray":
        """ Calculate the sum of weights, accounting for missing values """
    
        # we need to mask data values that are nan; else the weights are wrong
        mask = da.notnull()
    
>       sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:145: TypeError
______________ test_weighted_operations_keep_attr[None-False-sum] ______________

operation = 'sum', as_dataset = False, keep_attrs = None

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    @pytest.mark.parametrize("keep_attrs", (True, False, None))
    def test_weighted_operations_keep_attr(operation, as_dataset, keep_attrs):
    
        weights = DataArray(np.random.randn(2, 2), attrs=dict(attr="weights"))
        data = DataArray(np.random.randn(2, 2))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        data.attrs = dict(attr="weights")
    
>       result = getattr(data.weighted(weights), operation)(keep_attrs=True)

xarray/tests/test_weighted.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:197: in sum
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 2, dim_1: 2)>
array([[-0.95429638,  0.31860181],
       [ 1.11009257, -0.33228554]])
Dimensions without coordinates: dim_0, dim_1
Attributes:
    attr:     weights
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
_____________ test_weighted_operations_keep_attr[None-False-mean] ______________

operation = 'mean', as_dataset = False, keep_attrs = None

    @pytest.mark.parametrize("operation", ("sum_of_weights", "sum", "mean"))
    @pytest.mark.parametrize("as_dataset", (True, False))
    @pytest.mark.parametrize("keep_attrs", (True, False, None))
    def test_weighted_operations_keep_attr(operation, as_dataset, keep_attrs):
    
        weights = DataArray(np.random.randn(2, 2), attrs=dict(attr="weights"))
        data = DataArray(np.random.randn(2, 2))
    
        if as_dataset:
            data = data.to_dataset(name="data")
    
        data.attrs = dict(attr="weights")
    
>       result = getattr(data.weighted(weights), operation)(keep_attrs=True)

xarray/tests/test_weighted.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/weighted.py:208: in mean
    return self._implementation(
xarray/core/weighted.py:227: in _implementation
    weighted = func(self.obj, dim=dim, **kwargs)
xarray/core/weighted.py:170: in _weighted_mean
    weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DataArrayWeighted with weights along dimensions: dim_0, dim_1
da = <xarray.DataArray (dim_0: 2, dim_1: 2)>
array([[-1.06752078, -0.95335432],
       [-0.69970091, -0.35041494]])
Dimensions without coordinates: dim_0, dim_1
Attributes:
    attr:     weights
dim = None, skipna = None

    def _weighted_sum(
        self,
        da: "DataArray",
        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,
        skipna: Optional[bool] = None,
    ) -> "DataArray":
        """Reduce a DataArray by a by a weighted ``sum`` along some dimension(s)."""
    
>       return self._reduce(da, self.weights, dim=dim, skipna=skipna)
E       TypeError: Weighted._reduce() got multiple values for argument 'dim'

xarray/core/weighted.py:160: TypeError
=============================== warnings summary ===============================
xarray/__init__.py:1
  /testbed/xarray/__init__.py:1: DeprecationWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html
    import pkg_resources

xarray/core/dask_array_compat.py:16
xarray/core/dask_array_compat.py:16
  /testbed/xarray/core/dask_array_compat.py:16: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(dask_version) >= LooseVersion("2.0.0"):

xarray/core/dask_array_compat.py:149
xarray/core/dask_array_compat.py:149
  /testbed/xarray/core/dask_array_compat.py:149: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(dask_version) >= LooseVersion("2.8.1"):

xarray/core/dask_array_compat.py:186
xarray/core/dask_array_compat.py:186
  /testbed/xarray/core/dask_array_compat.py:186: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(dask_version) > LooseVersion("2.9.0"):

xarray/core/pdcompat.py:45
  /testbed/xarray/core/pdcompat.py:45: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(pd.__version__) < "0.25.0":

../opt/miniconda3/envs/testbed/lib/python3.10/site-packages/setuptools/_distutils/version.py:345
  /opt/miniconda3/envs/testbed/lib/python3.10/site-packages/setuptools/_distutils/version.py:345: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    other = LooseVersion(other)

xarray/tests/__init__.py:54
xarray/tests/__init__.py:54
  /testbed/xarray/tests/__init__.py:54: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    return version.LooseVersion(vstring)

xarray/tests/test_weighted.py: 2616 warnings
  /testbed/xarray/core/formatting.py:143: DeprecationWarning: `np.float` is a deprecated alias for the builtin `float`. To silence this warning, use `float` by itself. Doing this will not modify any behavior and is safe. If you specifically wanted the numpy scalar type, use `np.float64` here.
  Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
    elif isinstance(x, (float, np.float)):

xarray/tests/test_weighted.py: 10 warnings
  /testbed/xarray/core/alignment.py:304: FutureWarning: Index.__and__ operating as a set operation is deprecated, in the future this will be a logical operation matching Series.__and__.  Use index.intersection(other) instead.
    index = joiner(matching_indexes)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
==================================== PASSES ====================================
=========================== short test summary info ============================
PASSED xarray/tests/test_weighted.py::test_weighted_non_DataArray_weights[True]
PASSED xarray/tests/test_weighted.py::test_weighted_non_DataArray_weights[False]
PASSED xarray/tests/test_weighted.py::test_weighted_weights_nan_raises[weights0-True]
PASSED xarray/tests/test_weighted.py::test_weighted_weights_nan_raises[weights0-False]
PASSED xarray/tests/test_weighted.py::test_weighted_weights_nan_raises[weights1-True]
PASSED xarray/tests/test_weighted.py::test_weighted_weights_nan_raises[weights1-False]
XFAIL xarray/tests/test_weighted.py::test_weighted_operations_keep_attr_da_in_ds[sum] - xr.Dataset.map does not copy attrs of DataArrays GH: 3595
XFAIL xarray/tests/test_weighted.py::test_weighted_operations_keep_attr_da_in_ds[mean] - xr.Dataset.map does not copy attrs of DataArrays GH: 3595
FAILED xarray/tests/test_weighted.py::test_weighted_sum_of_weights_no_nan[weights0-3]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_of_weights_no_nan[weights1-2]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_of_weights_no_nan[weights2-nan]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_of_weights_no_nan[weights3-nan]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_of_weights_nan[weights0-2]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_of_weights_nan[weights1-nan]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_of_weights_nan[weights2-nan]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_of_weights_nan[weights3-1]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_of_weights_bool - Typ...
FAILED xarray/tests/test_weighted.py::test_weighted_sum_equal_weights[True-0-da0]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_equal_weights[True-0-da1]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_equal_weights[True-0-da2]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_equal_weights[True-1-da0]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_equal_weights[True-1-da1]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_equal_weights[True-1-da2]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_equal_weights[True-3.14-da0]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_equal_weights[True-3.14-da1]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_equal_weights[True-3.14-da2]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_equal_weights[False-0-da0]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_equal_weights[False-0-da1]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_equal_weights[False-0-da2]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_equal_weights[False-1-da0]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_equal_weights[False-1-da1]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_equal_weights[False-1-da2]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_equal_weights[False-3.14-da0]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_equal_weights[False-3.14-da1]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_equal_weights[False-3.14-da2]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_no_nan[weights0-5] - ...
FAILED xarray/tests/test_weighted.py::test_weighted_sum_no_nan[weights1-4] - ...
FAILED xarray/tests/test_weighted.py::test_weighted_sum_no_nan[weights2-0] - ...
FAILED xarray/tests/test_weighted.py::test_weighted_sum_nan[True-weights0-4]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_nan[True-weights1-4]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_nan[True-weights2-0]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_nan[True-weights3-0]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_nan[False-weights0-4]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_nan[False-weights1-4]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_nan[False-weights2-0]
FAILED xarray/tests/test_weighted.py::test_weighted_sum_nan[False-weights3-0]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_equal_weights[1-True-da0]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_equal_weights[1-True-da1]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_equal_weights[1-True-da2]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_equal_weights[1-False-da0]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_equal_weights[1-False-da1]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_equal_weights[1-False-da2]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_equal_weights[2-True-da0]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_equal_weights[2-True-da1]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_equal_weights[2-True-da2]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_equal_weights[2-False-da0]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_equal_weights[2-False-da1]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_equal_weights[2-False-da2]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_equal_weights[3.14-True-da0]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_equal_weights[3.14-True-da1]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_equal_weights[3.14-True-da2]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_equal_weights[3.14-False-da0]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_equal_weights[3.14-False-da1]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_equal_weights[3.14-False-da2]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_no_nan[weights0-1.6]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_no_nan[weights1-1.0]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_no_nan[weights2-nan]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_nan[True-weights0-2.0]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_nan[True-weights1-nan]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_nan[True-weights2-nan]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_nan[False-weights0-2.0]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_nan[False-weights1-nan]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_nan[False-weights2-nan]
FAILED xarray/tests/test_weighted.py::test_weighted_mean_bool - TypeError: We...
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-True-sum_of_weights-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-True-sum_of_weights-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-True-sum_of_weights-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-True-sum_of_weights-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-True-sum_of_weights-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-True-sum_of_weights-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-True-sum-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-True-sum-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-True-sum-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-True-sum-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-True-sum-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-True-sum-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-True-mean-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-True-mean-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-True-mean-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-True-mean-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-True-mean-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-True-mean-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-False-sum_of_weights-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-False-sum_of_weights-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-False-sum_of_weights-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-False-sum_of_weights-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-False-sum_of_weights-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-False-sum_of_weights-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-False-sum-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-False-sum-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-False-sum-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-False-sum-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-False-sum-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-False-sum-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-False-mean-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-False-mean-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-False-mean-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-False-mean-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-False-mean-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-None-False-mean-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-True-sum_of_weights-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-True-sum_of_weights-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-True-sum_of_weights-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-True-sum_of_weights-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-True-sum_of_weights-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-True-sum_of_weights-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-True-sum-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-True-sum-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-True-sum-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-True-sum-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-True-sum-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-True-sum-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-True-mean-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-True-mean-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-True-mean-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-True-mean-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-True-mean-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-True-mean-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-False-sum_of_weights-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-False-sum_of_weights-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-False-sum_of_weights-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-False-sum_of_weights-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-False-sum_of_weights-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-False-sum_of_weights-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-False-sum-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-False-sum-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-False-sum-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-False-sum-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-False-sum-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-False-sum-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-False-mean-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-False-mean-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-False-mean-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-False-mean-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-False-mean-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-True-False-mean-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-True-sum_of_weights-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-True-sum_of_weights-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-True-sum_of_weights-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-True-sum_of_weights-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-True-sum_of_weights-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-True-sum_of_weights-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-True-sum-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-True-sum-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-True-sum-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-True-sum-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-True-sum-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-True-sum-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-True-mean-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-True-mean-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-True-mean-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-True-mean-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-True-mean-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-True-mean-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-False-sum_of_weights-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-False-sum_of_weights-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-False-sum_of_weights-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-False-sum_of_weights-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-False-sum_of_weights-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-False-sum_of_weights-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-False-sum-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-False-sum-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-False-sum-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-False-sum-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-False-sum-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-False-sum-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-False-mean-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-False-mean-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-False-mean-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-False-mean-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-False-mean-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[True-False-False-mean-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-True-sum_of_weights-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-True-sum_of_weights-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-True-sum_of_weights-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-True-sum_of_weights-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-True-sum_of_weights-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-True-sum_of_weights-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-True-sum-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-True-sum-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-True-sum-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-True-sum-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-True-sum-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-True-sum-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-True-mean-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-True-mean-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-True-mean-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-True-mean-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-True-mean-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-True-mean-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-False-sum_of_weights-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-False-sum_of_weights-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-False-sum_of_weights-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-False-sum_of_weights-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-False-sum_of_weights-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-False-sum_of_weights-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-False-sum-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-False-sum-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-False-sum-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-False-sum-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-False-sum-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-False-sum-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-False-mean-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-False-mean-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-False-mean-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-False-mean-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-False-mean-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-None-False-mean-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-True-sum_of_weights-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-True-sum_of_weights-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-True-sum_of_weights-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-True-sum_of_weights-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-True-sum_of_weights-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-True-sum_of_weights-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-True-sum-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-True-sum-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-True-sum-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-True-sum-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-True-sum-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-True-sum-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-True-mean-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-True-mean-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-True-mean-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-True-mean-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-True-mean-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-True-mean-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-False-sum_of_weights-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-False-sum_of_weights-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-False-sum_of_weights-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-False-sum_of_weights-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-False-sum_of_weights-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-False-sum_of_weights-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-False-sum-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-False-sum-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-False-sum-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-False-sum-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-False-sum-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-False-sum-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-False-mean-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-False-mean-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-False-mean-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-False-mean-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-False-mean-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-True-False-mean-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-True-sum_of_weights-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-True-sum_of_weights-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-True-sum_of_weights-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-True-sum_of_weights-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-True-sum_of_weights-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-True-sum_of_weights-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-True-sum-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-True-sum-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-True-sum-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-True-sum-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-True-sum-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-True-sum-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-True-mean-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-True-mean-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-True-mean-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-True-mean-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-True-mean-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-True-mean-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-False-sum_of_weights-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-False-sum_of_weights-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-False-sum_of_weights-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-False-sum_of_weights-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-False-sum_of_weights-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-False-sum_of_weights-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-False-sum-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-False-sum-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-False-sum-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-False-sum-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-False-sum-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-False-sum-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-False-mean-a]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-False-mean-b]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-False-mean-c]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-False-mean-dim3]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-False-mean-dim4]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_3D[False-False-False-mean-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_nonequal_coords[True-sum_of_weights]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_nonequal_coords[True-sum]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_nonequal_coords[True-mean]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_nonequal_coords[False-sum_of_weights]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_nonequal_coords[False-sum]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_nonequal_coords[False-mean]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum_of_weights-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-sum-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-mean-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-mean-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-mean-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-mean-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-mean-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-mean-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-mean-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-mean-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-mean-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-mean-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-mean-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-mean-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-mean-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-mean-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-mean-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-mean-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-mean-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-True-mean-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum_of_weights-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-sum-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-mean-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-mean-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-mean-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-mean-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-mean-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-mean-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-mean-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-mean-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-mean-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-mean-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-mean-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-mean-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-mean-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-mean-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-mean-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-mean-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-mean-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-None-False-mean-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum_of_weights-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-sum-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-mean-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-mean-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-mean-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-mean-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-mean-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-mean-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-mean-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-mean-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-mean-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-mean-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-mean-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-mean-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-mean-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-mean-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-mean-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-mean-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-mean-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-True-mean-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum_of_weights-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-sum-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-mean-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-mean-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-mean-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-mean-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-mean-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-mean-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-mean-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-mean-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-mean-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-mean-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-mean-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-mean-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-mean-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-mean-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-mean-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-mean-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-mean-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-True-False-mean-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum_of_weights-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-sum-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-mean-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-mean-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-mean-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-mean-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-mean-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-mean-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-mean-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-mean-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-mean-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-mean-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-mean-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-mean-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-mean-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-mean-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-mean-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-mean-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-mean-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-True-mean-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum_of_weights-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-sum-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-mean-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-mean-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-mean-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-mean-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-mean-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-mean-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-mean-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-mean-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-mean-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-mean-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-mean-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-mean-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-mean-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-mean-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-mean-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-mean-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-mean-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[True-False-False-mean-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum_of_weights-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-sum-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-mean-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-mean-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-mean-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-mean-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-mean-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-mean-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-mean-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-mean-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-mean-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-mean-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-mean-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-mean-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-mean-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-mean-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-mean-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-mean-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-mean-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-True-mean-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum_of_weights-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-sum-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-mean-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-mean-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-mean-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-mean-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-mean-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-mean-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-mean-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-mean-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-mean-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-mean-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-mean-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-mean-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-mean-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-mean-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-mean-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-mean-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-mean-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-None-False-mean-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum_of_weights-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-sum-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-mean-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-mean-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-mean-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-mean-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-mean-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-mean-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-mean-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-mean-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-mean-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-mean-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-mean-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-mean-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-mean-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-mean-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-mean-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-mean-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-mean-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-True-mean-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum_of_weights-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-sum-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-mean-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-mean-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-mean-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-mean-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-mean-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-mean-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-mean-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-mean-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-mean-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-mean-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-mean-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-mean-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-mean-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-mean-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-mean-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-mean-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-mean-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-True-False-mean-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum_of_weights-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-sum-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-mean-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-mean-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-mean-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-mean-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-mean-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-mean-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-mean-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-mean-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-mean-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-mean-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-mean-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-mean-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-mean-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-mean-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-mean-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-mean-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-mean-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-True-mean-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum_of_weights-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-sum-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-mean-shape_weights0-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-mean-shape_weights0-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-mean-shape_weights0-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-mean-shape_weights0-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-mean-shape_weights0-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-mean-shape_weights0-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-mean-shape_weights1-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-mean-shape_weights1-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-mean-shape_weights1-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-mean-shape_weights1-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-mean-shape_weights1-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-mean-shape_weights1-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-mean-shape_weights2-shape_data0-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-mean-shape_weights2-shape_data0-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-mean-shape_weights2-shape_data1-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-mean-shape_weights2-shape_data1-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-mean-shape_weights2-shape_data2-dim_0]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_different_shapes[False-False-False-mean-shape_weights2-shape_data2-None]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_keep_attr[True-True-sum_of_weights]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_keep_attr[True-True-sum]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_keep_attr[True-True-mean]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_keep_attr[True-False-sum_of_weights]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_keep_attr[True-False-sum]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_keep_attr[True-False-mean]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_keep_attr[False-True-sum_of_weights]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_keep_attr[False-True-sum]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_keep_attr[False-True-mean]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_keep_attr[False-False-sum_of_weights]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_keep_attr[False-False-sum]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_keep_attr[False-False-mean]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_keep_attr[None-True-sum_of_weights]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_keep_attr[None-True-sum]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_keep_attr[None-True-mean]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_keep_attr[None-False-sum_of_weights]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_keep_attr[None-False-sum]
FAILED xarray/tests/test_weighted.py::test_weighted_operations_keep_attr[None-False-mean]
=========== 954 failed, 6 passed, 2 xfailed, 2637 warnings in 38.60s ===========
+ : '>>>>> End Test Output'
+ git checkout 19b088636eb7d3f65ab7a1046ac672e0689371d8 xarray/tests/test_weighted.py
Updated 1 path from 3bf98cbd
