diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py
index 95302a05ca..e5c89f724a 100644
--- a/sympy/matrices/expressions/blockmatrix.py
+++ b/sympy/matrices/expressions/blockmatrix.py
@@ -164,10 +164,41 @@ def structurally_equal(self, other):
     def _blockmul(self, other):
         if (isinstance(other, BlockMatrix) and
                 self.colblocksizes == other.rowblocksizes):
-            return BlockMatrix(self.blocks*other.blocks)
+            return self._blockmul_blockmatrix(other)
 
         return self * other
 
+    def _blockmul_blockmatrix(self, other):
+        # Perform proper block matrix multiplication that preserves
+        # ZeroMatrix types instead of converting them to Zero (scalar)
+
+        from sympy.matrices.immutable import ImmutableDenseMatrix
+        from sympy.matrices.expressions.matexpr import ZeroMatrix
+
+        blocks = self.blocks
+        other_blocks = other.blocks
+        m, n = blocks.shape
+        p = other_blocks.shape[1]
+
+        # Initialize result blocks matrix with ZeroMatrix
+        result_blocks = [[ZeroMatrix(self.rowblocksizes[i], other.colblocksizes[j])
+                         for j in range(p)] for i in range(m)]
+
+        # Block matrix multiplication: C[i,j] = sum(A[i,k] * B[k,j])
+        for i in range(m):
+            for j in range(p):
+                for k in range(n):
+                    A = blocks[i, k]
+                    B = other_blocks[k, j]
+
+                    # Skip multiplication if either block is a ZeroMatrix
+                    if A.is_ZeroMatrix or B.is_ZeroMatrix:
+                        continue
+
+                    result_blocks[i][j] = result_blocks[i][j] + A * B
+
+        return BlockMatrix(ImmutableDenseMatrix(result_blocks))
+
     def _blockadd(self, other):
         if (isinstance(other, BlockMatrix)
                 and self.structurally_equal(other)):